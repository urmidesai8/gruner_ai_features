<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Dual-User Chat Simulation</title>
    <!-- Material Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined" rel="stylesheet">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
            height: 100vh;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            margin-top: 60px;
            /* Prevent overlap with fixed AI toggle */
        }

        .main-container {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            /* User 1 | Chat | User 2 */
            gap: 20px;
            flex: 1;
            min-height: 0;
            /* Important for scroll */
        }

        .user-panel {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .user-panel h2 {
            border-bottom: 2px solid #ddd;
            padding-bottom: 10px;
            margin-top: 0;
            text-align: center;
        }

        .user-1-panel h2 {
            border-color: #2196F3;
            color: #2196F3;
        }

        .user-2-panel h2 {
            border-color: #E91E63;
            color: #E91E63;
        }

        .chat-container {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        #messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .message {
            max-width: 80%;
            padding: 10px 15px;
            border-radius: 15px;
            position: relative;
            word-wrap: break-word;
        }

        .message.left {
            align-self: flex-start;
            background-color: #e3f2fd;
            /* Light Blue */
            color: #0d47a1;
            border-bottom-left-radius: 2px;
        }

        .message.right {
            align-self: flex-end;
            background-color: #fce4ec;
            /* Light Pink */
            color: #880e4f;
            border-bottom-right-radius: 2px;
        }

        .message-header {
            font-size: 0.75em;
            margin-bottom: 5px;
            opacity: 0.7;
            font-weight: bold;
        }

        .controls {
            padding: 15px;
            background: #f9f9f9;
            border-top: 1px solid #eee;
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
        }

        textarea {
            width: 100%;
            resize: vertical;
            min-height: 80px;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            font-family: inherit;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        button.send-btn {
            width: 100%;
        }

        .btn-user1 {
            background-color: #2196F3;
            color: white;
        }

        .btn-user1:hover {
            background-color: #1976D2;
        }

        .btn-user2 {
            background-color: #E91E63;
            color: white;
        }

        .btn-user2:hover {
            background-color: #C2185B;
        }

        .btn-ai {
            background-color: #6200ea;
            /* Deep Purple */
            color: white;
        }

        .btn-ai:hover {
            background-color: #3700b3;
        }

        select {
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            flex: 1;
        }

        /* AI Metadata Styles */
        .tag {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.75em;
            margin-left: 5px;
            font-weight: bold;
        }

        .tag-urgent {
            background: #ff5252;
            color: white;
        }

        .tag-high {
            background: #ff9100;
            color: white;
        }

        .tag-normal {
            background: #bbb;
            color: white;
        }

        .tag-safe {
            background: #4caf50;
            color: white;
        }

        .tag-unsafe {
            background: #f44336;
            color: white;
        }

        .suggestion-box {
            background: #fff3e0;
            padding: 10px;
            margin-top: 5px;
            border-left: 3px solid #ff9800;
            font-size: 0.9em;
        }

        .suggestion-btn {
            background: white;
            border: 1px solid #ff9800;
            color: #bf360c;
            padding: 3px 8px;
            margin: 2px;
            cursor: pointer;
            font-size: 0.85em;
        }

        /* Summary and Tasks Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            border-radius: 10px;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: black;
        }

        .summary-section {
            margin: 20px 0;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 5px;
        }

        .summary-section h3 {
            margin-top: 0;
            color: #2196F3;
        }

        .summary-section ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .summary-section li {
            margin: 5px 0;
        }

        /* Reminder Styles */
        .reminder-suggestion {
            background: #f0f7ff;
            border: 1px solid #2196F3;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            cursor: pointer;
            transition: background 0.2s;
        }

        .reminder-suggestion:hover {
            background: #e3f2fd;
        }

        .reminder-suggestion h4 {
            margin: 0 0 8px 0;
            color: #1976D2;
        }

        .reminder-meta {
            font-size: 0.85em;
            color: #666;
            margin: 5px 0;
        }

        .reminder-priority {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: bold;
            margin-right: 8px;
        }

        .priority-high {
            background: #ff5252;
            color: white;
        }

        .priority-medium {
            background: #ff9800;
            color: white;
        }

        .priority-low {
            background: #9e9e9e;
            color: white;
        }

        .reminder-actions {
            margin-top: 10px;
            display: flex;
            gap: 8px;
        }

        .btn-create-reminder {
            background: #4caf50;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
        }

        .btn-create-reminder:hover {
            background: #45a049;
        }

        .reminder-created {
            background: #e8f5e9;
            border: 1px solid #4caf50;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .task-reminder-btn {
            background: #2196F3;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            margin-top: 8px;
        }

        .task-reminder-btn:hover {
            background: #1976D2;
        }

        .btn-icon {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            cursor: pointer;
            margin-right: 5px;
            color: #555;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .btn-icon .material-icons-outlined {
            font-size: 20px;
        }

        .btn-icon:hover {
            background: #f0f0f0;
            color: #2196F3;
            border-color: #2196F3;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .btn-icon.recording {
            background: #ffcdd2;
            border-color: #f44336;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.4);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(244, 67, 54, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(244, 67, 54, 0);
            }
        }

        /* Translation styles */
        .translation-box {
            margin-top: 8px;
            padding: 8px 10px;
            border-radius: 8px;
            background: #f1f8e9;
            border-left: 3px solid #8bc34a;
            font-size: 0.9em;
        }

        .auto-translation-box {
            margin-top: 8px;
            padding: 8px 10px;
            border-radius: 8px;
            background: #e8f5e9;
            border-left: 3px solid #4caf50;
            font-size: 0.85em;
            opacity: 0.9;
        }

        .translation-header {
            font-weight: bold;
            color: #558b2f;
            margin-bottom: 4px;
        }

        .auto-translation-box .translation-header {
            font-size: 0.85em;
            color: #2e7d32;
        }

        /* AI Toggle Switch Styles */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.toggle-slider {
            background-color: #4caf50;
        }

        input:checked+.toggle-slider:before {
            transform: translateX(26px);
        }

        input:disabled+.toggle-slider {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .ai-disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        /* AI Toggle in Top Right Corner */
        .ai-toggle-container {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            z-index: 1000;
        }

        .ai-toggle-container label {
            margin: 0;
            font-weight: bold;
            color: #333;
            font-size: 0.9em;
        }

        .ai-toggle-container #aiStatusText {
            font-size: 0.9em;
            font-weight: bold;
            min-width: 35px;
        }
    </style>
</head>

<body>

    <!-- AI Toggle and Model Selector in Top Right Corner -->
    <div class="ai-toggle-container">
        <select id="aiModelSelector"
            style="margin-right: 10px; padding: 5px; border-radius: 5px; border: 1px solid #ccc; font-size: 0.9em;">
            <option value="llama-3.3-70b-versatile">Llama 3.3 70B (Versatile)</option>
            <option value="llama-3.1-8b-instant">Llama 3.1 8B (Instant)</option>
            <option value="mixtral-8x7b-32768">Mixtral 8x7B</option>
            <option value="gemma2-9b-it">Gemma 2 9B</option>
            <option value="deepseek-r1-distill-llama-70b">DeepSeek R1 Distill 70B</option>
            <option value="openai/gpt-oss-120b">GPT OSS 120B</option>
        </select>
        <label for="aiToggle">
            <span id="aiStatusLabel">AI Features: </span>
        </label>
        <label class="toggle-switch">
            <input type="checkbox" id="aiToggle" checked>
            <span class="toggle-slider"></span>
        </label>
        <span id="aiStatusText" style="color: #4caf50; font-weight: bold;">ON</span>
    </div>

    <h1>Dual-User Simulation & AI Features</h1>

    <div class="main-container">
        <!-- USER 1 PANEL -->
        <div class="user-panel user-1-panel">
            <h2>User 1</h2>
            <div id="user1LanguageContainer" style="display: none; margin-bottom: 10px;">
                <label for="user1Language"
                    style="font-size: 0.9em; font-weight: bold; display: block; margin-bottom: 5px;">Auto-translate
                    to:</label>
                <select id="user1Language"
                    style="width: 100%; padding: 8px; border-radius: 5px; border: 1px solid #ccc;">
                    <option value="">-- No translation --</option>
                    <option value="en">English</option>
                    <option value="es">Spanish</option>
                    <option value="fr">French</option>
                    <option value="de">German</option>
                    <option value="hi">Hindi</option>
                    <option value="zh">Chinese</option>
                    <option value="ja">Japanese</option>
                </select>
            </div>
            <textarea id="input1" placeholder="Type as User 1..."></textarea>
            <div class="audio-controls" style="margin-bottom: 5px; display: flex; gap: 5px;">
                <button class="btn-icon" onclick="toggleRecording('user1')" title="Record Audio">
                    <span class="material-icons-outlined">mic</span>
                </button>
                <button class="btn-icon" onclick="triggerFileUpload('user1')" title="Upload Audio">
                    <span class="material-icons-outlined">upload_file</span>
                </button>
                <input type="file" id="fileInput1" accept="audio/*" style="display: none;"
                    onchange="handleFileUpload(this, 'user1')">
                <span id="recordingStatus1"
                    style="font-size: 0.8em; color: red; display: none; align-self: center;">Recording...</span>
            </div>
            <button class="send-btn btn-user1" onclick="sendUser1()">Send >></button>
            <div id="status1" style="font-size:0.8em; color:gray; text-align:center;">Disconnected</div>
        </div>

        <!-- CENTER CHAT AREA -->
        <div class="chat-container">
            <div id="messages"></div>

            <!-- AI CONTROLS -->
            <div class="controls">
                <label for="featureSelect"><strong>AI Feature:</strong></label>
                <select id="featureSelect">
                    <option value="none">-- Select Feature --</option>
                    <option value="prioritize">Message Prioritization</option>
                    <option value="moderate">AI Moderation</option>
                    <option value="smart_replies">Smart Replies</option>
                    <option value="summary">Chat Summary</option>
                    <option value="tasks">Extract Tasks</option>
                    <option value="reminders">Smart Reminders</option>
                    <option value="translate">Language Translation</option>
                    <option value="transcribe">Audio Transcription</option>
                </select>
                <label for="translationLanguage" id="translationLanguageLabel"
                    style="display: none;"><strong>Language:</strong></label>
                <select id="translationLanguage" style="display: none;">
                    <option value="en">English</option>
                    <option value="es">Spanish</option>
                    <option value="fr">French</option>
                    <option value="de">German</option>
                    <option value="hi">Hindi</option>
                    <option value="zh">Chinese</option>
                    <option value="ja">Japanese</option>
                </select>
                <label for="replyTone" id="replyToneLabel" style="display: none;"><strong>Tone:</strong></label>
                <select id="replyTone" style="display: none;">
                    <option value="auto">Auto</option>
                    <option value="professional">Professional</option>
                    <option value="casual">Casual</option>
                    <option value="friendly">Friendly</option>
                    <option value="formal">Formal</option>
                </select>
                <button class="btn-ai" onclick="runAIFeature()">Run Analysis</button>
            </div>
            <div id="aiStatus" style="font-size:0.8em; color:gray; text-align:center; padding-bottom: 5px;">Ready</div>
        </div>

        <!-- USER 2 PANEL -->
        <div class="user-panel user-2-panel">
            <h2>User 2</h2>
            <div id="user2LanguageContainer" style="display: none; margin-bottom: 10px;">
                <label for="user2Language"
                    style="font-size: 0.9em; font-weight: bold; display: block; margin-bottom: 5px;">Auto-translate
                    to:</label>
                <select id="user2Language"
                    style="width: 100%; padding: 8px; border-radius: 5px; border: 1px solid #ccc;">
                    <option value="">-- No translation --</option>
                    <option value="en">English</option>
                    <option value="es">Spanish</option>
                    <option value="fr">French</option>
                    <option value="de">German</option>
                    <option value="hi">Hindi</option>
                    <option value="zh">Chinese</option>
                    <option value="ja">Japanese</option>
                </select>
            </div>
            <textarea id="input2" placeholder="Type as User 2..."></textarea>
            <div class="audio-controls" style="margin-bottom: 5px; display: flex; gap: 5px;">
                <button class="btn-icon" onclick="toggleRecording('user2')" title="Record Audio">
                    <span class="material-icons-outlined">mic</span>
                </button>
                <button class="btn-icon" onclick="triggerFileUpload('user2')" title="Upload Audio">
                    <span class="material-icons-outlined">upload_file</span>
                </button>
                <input type="file" id="fileInput2" accept="audio/*" style="display: none;"
                    onchange="handleFileUpload(this, 'user2')">
                <span id="recordingStatus2"
                    style="font-size: 0.8em; color: red; display: none; align-self: center;">Recording...</span>
            </div>
            <button class="send-btn btn-user2" onclick="sendUser2()">
                << Send</button>
                    <div id="status2" style="font-size:0.8em; color:gray; text-align:center;">Disconnected</div>
        </div>
    </div>

    <!-- Summary Modal -->
    <div id="summaryModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeSummary()">&times;</span>
            <h2>Chat Summary</h2>
            <div style="margin-bottom: 15px;">
                <label for="summaryTotalMessages">Number of recent messages to summarize: </label>
                <input type="number" id="summaryTotalMessages" value="100" min="1" max="1000"
                    style="width: 100px; padding: 5px; margin-left: 10px;">
                <small style="display: block; color: #666; margin-top: 5px;">Default: 100 (last 100 messages)</small>
            </div>
            <div id="summaryLoading" style="display: none; text-align: center; padding: 20px;">Generating summary...
            </div>
            <div id="summaryResults"></div>
        </div>
    </div>

    <!-- Tasks Modal -->
    <div id="tasksModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeTasks()">&times;</span>
            <h2>Chat Tasks / To-Dos</h2>
            <div id="tasksLoading" style="display: none; text-align: center; padding: 20px;">Extracting tasks...</div>
            <div id="tasksResults"></div>
        </div>
    </div>

    <!-- Reminders Modal -->
    <div id="remindersModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeReminders()">&times;</span>
            <h2>Smart Reminder Suggestions</h2>
            <div style="margin-bottom: 15px;">
                <label for="reminderContextWindow">Context Window (recent messages): </label>
                <input type="number" id="reminderContextWindow" value="" placeholder="All messages" min="1"
                    style="width: 100px; padding: 5px; margin-left: 10px;">
            </div>
            <div id="remindersLoading" style="display: none; text-align: center; padding: 20px;">Generating reminder
                suggestions...</div>
            <div id="remindersResults"></div>
        </div>
    </div>

    <!-- Transcription Modal -->
    <div id="transcriptionModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeTranscription()">&times;</span>
            <h2>Audio Transcription</h2>
            <div style="margin-bottom: 20px; text-align: center;">
                <input type="file" id="audioInput" accept="audio/*" style="display: block; margin: 10px auto;">
                <button class="btn-ai" onclick="uploadForTranscription()">Transcribe Now</button>
                <div id="transcriptionActions" style="display:none; margin-top: 10px;">
                    <button class="btn-ai" style="background-color: #ff9800;"
                        onclick="generateTranscriptSummary()">Generate Summary</button>

                    <select id="transcriptLangSelect" style="padding: 8px; border-radius: 5px; margin-left: 10px;">
                        <option value="es">Spanish</option>
                        <option value="fr">French</option>
                        <option value="de">German</option>
                        <option value="hi">Hindi</option>
                        <option value="ja">Japanese</option>
                        <option value="zh">Chinese</option>
                        <option value="en">English</option>
                    </select>
                    <button class="btn-ai" style="background-color: #2196F3; margin-left: 5px;"
                        onclick="translateTranscript()">Translate</button>
                </div>
            </div>
            <div id="transcriptionLoading" style="display: none; text-align: center; padding: 20px;">Transcribing audio
                file...</div>
            <div id="transcriptionResults"
                style="white-space: pre-wrap; background: #f9f9f9; padding: 15px; border-radius: 5px; margin-top: 10px; min-height: 100px;">
            </div>
            <!-- Translation Result -->
            <div id="transcriptionTranslationResult"
                style="margin-top: 20px; border-top: 1px solid #ccc; padding-top: 10px;"></div>
            <!-- Summary Result -->
            <div id="transcriptionSummaryResult"
                style="margin-top: 20px; border-top: 1px solid #ccc; padding-top: 10px;"></div>

        </div>
    </div>
    </div>
    </div>



    <script>
        // --- WebSocket Setup ---
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const host = window.location.host;

        let ws1, ws2;
        const user1Name = "User 1";
        const user2Name = "User 2";

        // Global store for messages to easily update UI
        let chatMessages = [];

        // AI state tracking
        let aiEnabled = true;

        // Utility function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Initialize AI status on page load
        async function initializeAIStatus() {
            try {
                const response = await fetch('/api/features/ai-status');
                const data = await response.json();
                aiEnabled = data.ai_enabled;
                updateAIToggleUI();
            } catch (error) {
                console.error('Error fetching AI status:', error);
            }
        }

        // Update AI toggle UI
        function updateAIToggleUI() {
            const toggle = document.getElementById('aiToggle');
            const statusText = document.getElementById('aiStatusText');
            const featureSelect = document.getElementById('featureSelect');
            const runButton = document.querySelector('.btn-ai');
            const user1LangContainer = document.getElementById('user1LanguageContainer');
            const user2LangContainer = document.getElementById('user2LanguageContainer');

            if (toggle) {
                toggle.checked = aiEnabled;
            }

            if (statusText) {
                statusText.textContent = aiEnabled ? 'ON' : 'OFF';
                statusText.style.color = aiEnabled ? '#4caf50' : '#f44336';
            }

            // Show/hide language dropdowns based on AI state
            if (user1LangContainer) {
                user1LangContainer.style.display = aiEnabled ? 'block' : 'none';
            }
            if (user2LangContainer) {
                user2LangContainer.style.display = aiEnabled ? 'block' : 'none';
            }

            // If AI is off, reset language selections and remove translations
            if (!aiEnabled) {
                const user1Lang = document.getElementById('user1Language');
                const user2Lang = document.getElementById('user2Language');
                if (user1Lang) user1Lang.value = '';
                if (user2Lang) user2Lang.value = '';
                // Remove all existing auto-translations
                document.querySelectorAll('.auto-translation-box').forEach(el => el.remove());
            }

            // Disable/enable AI features (except summary)
            if (featureSelect) {
                const options = featureSelect.querySelectorAll('option');
                options.forEach(option => {
                    if (option.value !== 'none' && option.value !== 'summary') {
                        option.disabled = !aiEnabled;
                    }
                });

                // If current selection is disabled, reset to none
                if (!aiEnabled && featureSelect.value !== 'none' && featureSelect.value !== 'summary') {
                    featureSelect.value = 'none';
                }
            }

            // Update run button
            if (runButton) {
                if (!aiEnabled && featureSelect && featureSelect.value !== 'none' && featureSelect.value !== 'summary') {
                    runButton.disabled = true;
                    runButton.style.opacity = '0.5';
                    runButton.style.cursor = 'not-allowed';
                } else {
                    runButton.disabled = false;
                    runButton.style.opacity = '1';
                    runButton.style.cursor = 'pointer';
                }
            }
        }

        // Toggle AI state
        async function toggleAI() {
            const toggle = document.getElementById('aiToggle');
            const newState = toggle.checked;

            try {
                const response = await fetch('/api/features/ai-toggle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: newState })
                });

                const data = await response.json();
                aiEnabled = data.ai_enabled;
                updateAIToggleUI();

                // Show notification
                const statusEl = document.getElementById('aiStatus');
                if (statusEl) {
                    statusEl.textContent = data.message;
                    statusEl.style.color = aiEnabled ? '#4caf50' : '#f44336';
                    setTimeout(() => {
                        statusEl.textContent = 'Ready';
                        statusEl.style.color = 'gray';
                    }, 3000);
                }
            } catch (error) {
                console.error('Error toggling AI:', error);
                toggle.checked = !newState; // Revert toggle
                alert('Failed to toggle AI state. Please try again.');
            }
        }

        function connect() {
            // Connect User 1
            ws1 = new WebSocket(`${protocol}//${host}/ws?username=${encodeURIComponent(user1Name)}`);
            ws1.onopen = () => updateStatus('status1', 'Connected (Online)', 'green');
            ws1.onclose = () => updateStatus('status1', 'Disconnected', 'red');
            ws1.onmessage = (e) => handleMessage(e);

            // Connect User 2
            ws2 = new WebSocket(`${protocol}//${host}/ws?username=${encodeURIComponent(user2Name)}`);
            ws2.onopen = () => updateStatus('status2', 'Connected (Online)', 'green');
            ws2.onclose = () => updateStatus('status2', 'Disconnected', 'red');
            ws2.onmessage = (e) => handleMessage(e); // Both listen, but backend broadcasts to all
        }

        function updateStatus(elemId, text, color) {
            const el = document.getElementById(elemId);
            el.textContent = text;
            el.style.color = color;
        }

        // Handle incoming messages
        function handleMessage(event) {
            const data = JSON.parse(event.data);

            // We only care about actual 'message' types to display in the main chat
            // Dual connection means we might receive duplicates if we aren't careful, 
            // but the backend `exclude_user_id` logic usually handles "echo".
            // However, since we have ONE UI showing ALL messages, we need to be careful.
            // Simplified: The backend broadcasts to everyone including sender (simpler for state sync).

            // In the provided `main.py`, it uses `exclude_user_id`.
            // So User 1 sends -> Backend -> User 2 receives.
            // User 1 needs to see their own message. 
            // We'll handle "own message" display in the send function for immediate feedback,
            // OR better: we utilize the existing logic.
            // Let's just listen. User 1 sends. User 2 receives. 
            // Since this is a "Central View", we should just append messages as they come In.
            // Problem: ws1.onmessage only gets messages from OTHERS (User 2).
            // ws2.onmessage only gets messages from OTHERS (User 1).
            // So if User 1 sends, ws2 receives it. We display it.
            // If User 2 sends, ws1 receives it. We display it.
            // Perfect!

            if (data.type === 'message') {
                displayMessage(data);
            }
        }

        function renderMessageContent(text, msgId) {
            if (text.startsWith('[AUDIO]: ')) {
                const url = text.substring(9);
                const filename = url.split('/').pop();
                const actionId = 'audio-actions-' + msgId;

                return `
                    <audio controls src="${url}" style="width: 200px;"></audio>
                    <div style="margin-top: 5px;">
                        <button class="suggestion-btn" onclick="transcribeAudioMsg('${filename}', '${actionId}')">Transcribe</button>
                        <button class="suggestion-btn" onclick="summarizeAudioMsg('${filename}', '${actionId}')">Summary</button>
                        <button class="suggestion-btn" onclick="translateAudioMsg('${filename}', '${actionId}')">Translate</button>
                    </div>
                    <div id="${actionId}"></div>
                `;
            }
            return escapeHtml(text);
        }

        function displayMessage(msgData) {
            // Avoid duplicates if both sockets receive notifications (e.g. system messages)
            // For simple chat messages between 2 people, it's distinct.

            const container = document.getElementById('messages');
            const div = document.createElement('div');

            const isUser1 = msgData.sender === user1Name;
            div.className = `message ${isUser1 ? 'left' : 'right'}`;
            div.dataset.id = msgData.message_id || Date.now(); // Ensure ID exists for AI features

            div.innerHTML = `
                <div class="message-header">${msgData.sender}</div>
                <div class="message-body">
                    ${renderMessageContent(msgData.message, div.dataset.id)}
                </div>
                <div class="ai-tags"></div>
            `;

            container.appendChild(div);
            container.scrollTop = container.scrollHeight;

            // Keep track for AI analysis
            // Note: ai_enabled is tracked on backend, but we'll filter on frontend too
            const messageObj = {
                id: div.dataset.id,
                sender: msgData.sender,
                message: msgData.message,
                element: div,
                ai_enabled: msgData.ai_enabled !== undefined ? msgData.ai_enabled : aiEnabled
            };
            chatMessages.push(messageObj);

            // Auto-translate if AI is enabled and user has selected a language
            if (aiEnabled && msgData.ai_enabled !== false) {
                autoTranslateMessage(messageObj);
            }
        }

        async function sendUser1() {
            const input = document.getElementById('input1');
            const text = input.value.trim();
            if (!text) return;

            // Send via WS - Do NOT display locally, wait for WS echo/broadcast to other user
            ws1.send(JSON.stringify({ message: text }));

            input.value = '';
        }

        async function sendUser2() {
            const input = document.getElementById('input2');
            const text = input.value.trim();
            if (!text) return;

            // Send via WS
            ws2.send(JSON.stringify({ message: text }));

            input.value = '';
        }

        // --- Audio Messaging Functions ---
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false; // Simple state tracking (per user would be better but simple for now)
        let currentRecordingUser = null;

        async function toggleRecording(user) {
            const statusEl = document.getElementById(user === 'user1' ? 'recordingStatus1' : 'recordingStatus2');
            const btn = document.querySelector(`.user-${user === 'user1' ? '1' : '2'}-panel .btn-icon[title="Record Audio"]`);

            if (!isRecording) {
                // Start Recording
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    currentRecordingUser = user;

                    mediaRecorder.ondataavailable = event => {
                        audioChunks.push(event.data);
                    };

                    mediaRecorder.onstop = async () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        // Create a file from blob
                        const file = new File([audioBlob], "recording.webm", { type: 'audio/webm' });
                        await uploadAudioFile(file, user);

                        // Reset UI
                        statusEl.style.display = 'none';
                        btn.classList.remove('recording');
                        isRecording = false;
                        currentRecordingUser = null;

                        // Stop all tracks
                        stream.getTracks().forEach(track => track.stop());
                    };

                    mediaRecorder.start();
                    isRecording = true;
                    statusEl.style.display = 'inline';
                    btn.classList.add('recording');

                } catch (err) {
                    console.error("Error accessing microphone:", err);
                    alert("Could not access microphone.");
                }
            } else {
                // Stop Recording
                if (currentRecordingUser !== user) {
                    alert("Another recording is in progress.");
                    return;
                }
                mediaRecorder.stop();
            }
        }

        function triggerFileUpload(user) {
            document.getElementById(user === 'user1' ? 'fileInput1' : 'fileInput2').click();
        }

        async function handleFileUpload(input, user) {
            if (input.files && input.files[0]) {
                await uploadAudioFile(input.files[0], user);
                input.value = ''; // Reset
            }
        }

        async function uploadAudioFile(file, user) {
            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/api/features/upload-audio', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) throw new Error('Upload failed');

                const data = await response.json();
                const audioUrl = data.url;

                // Send as special formatted message: [AUDIO]: URL
                const message = `[AUDIO]: ${audioUrl}`;

                if (user === 'user1') {
                    ws1.send(JSON.stringify({ message: message }));
                } else {
                    ws2.send(JSON.stringify({ message: message }));
                }

            } catch (error) {
                console.error("Error uploading audio:", error);
                alert("Failed to send audio.");
            }
        }

        async function transcribeAudioMsg(filename, elementId) {
            const container = document.getElementById(elementId);
            container.innerHTML = 'Transcribing...';

            try {
                const response = await fetch('/api/features/transcribe-file', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filename: filename })
                });

                const data = await response.json();
                if (!response.ok) throw new Error(data.detail || 'Transcription failed');

                container.innerHTML = `<div style="margin-top:5px; padding:5px; background:#f0f0f0; border-radius:4px;"><strong>Transcript:</strong> ${escapeHtml(data.transcription)}</div>`;

            } catch (error) {
                container.innerHTML = `<span style="color:red">Error: ${error.message}</span>`;
            }
        }

        async function summarizeAudioMsg(filename, elementId) {
            const container = document.getElementById(elementId);
            container.innerHTML = 'Summarizing...';
            const model = getSelectedModel();

            try {
                // First Transcribe
                const transResponse = await fetch('/api/features/transcribe-file', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filename: filename })
                });
                const transData = await transResponse.json();
                if (!transResponse.ok) throw new Error(transData.detail || 'Transcription failed');

                const text = transData.transcription;

                // Then Summarize
                const sumResponse = await fetch('/api/features/summarize-text', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: text, model: model })
                });

                const sumData = await sumResponse.json();
                if (!sumResponse.ok) throw new Error(sumData.detail || 'Summarization failed');

                container.innerHTML = `
                    <div style="margin-top:5px; padding:5px; background:#fff3e0; border-radius:4px;">
                        <strong>Summary:</strong>
                        <p>${escapeHtml(sumData.summary)}</p>
                    </div>
                 `;

            } catch (error) {
                container.innerHTML = `<span style="color:red">Error: ${error.message}</span>`;
            }
        }

        async function translateAudioMsg(filename, elementId) {
            const container = document.getElementById(elementId);
            container.innerHTML = 'Translating...';
            const model = getSelectedModel();

            // Determine receiving user language
            // Since we don't know who is viewing (simulated one-screen), 
            // we'll try to guess based on who SENT it. 
            // If User 1 sent it, translate to User 2's language, and vice-versa.

            // However, we don't have the message element here easily to check sender.
            // But we can check `currentRecordingUser` if it was just recorded? No.
            // Let's pass the message ID or something? 
            // `filename` has `user1_` or `user2_` prefix usually? No, uuid.

            // Simpler: Just try to find which user sent it by checking the message div? 
            // The `elementId` is `audio-actions-[msgId]`.
            const msgId = elementId.replace('audio-actions-', '');
            // We need to look up the message in `chatMessages` array
            const msgObj = chatMessages.find(m => m.id === msgId || m.id == msgId);

            if (!msgObj) {
                container.innerHTML = 'Error: Message not found.';
                return;
            }

            const sender = msgObj.sender === user1Name ? 'user1' : 'user2';
            const receiver = sender === 'user1' ? 'user2' : 'user1';
            const langSelect = document.getElementById(`${receiver}Language`);

            if (!langSelect || !langSelect.value) {
                container.innerHTML = `<span style="color:orange">Please select a language for ${receiver === 'user1' ? user1Name : user2Name}.</span>`;
                return;
            }

            const targetLang = langSelect.value;

            try {
                // 1. Transcribe
                const transResponse = await fetch('/api/features/transcribe-file', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filename: filename })
                });
                const transData = await transResponse.json();
                if (!transResponse.ok) throw new Error(transData.detail || 'Transcription failed');
                const text = transData.transcription;

                // 2. Translate
                // Use generic translate-text endpoint
                const transTextResponse = await fetch('/api/features/translate-text', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: text,
                        target_language: targetLang,
                        model: model
                    })
                });

                const transTextData = await transTextResponse.json();
                if (!transTextResponse.ok) throw new Error(transTextData.detail || 'Translation failed');

                container.innerHTML = `
                    <div style="margin-top:5px; padding:5px; background:#e8f5e9; border-radius:4px;">
                        <strong>Translated (${targetLang}):</strong>
                        <p>${escapeHtml(transTextData.translated_text)}</p>
                    </div>
                `;

            } catch (error) {
                container.innerHTML = `<span style="color:red">Error: ${error.message}</span>`;
            }
        }

        // --- AI Features ---

        // Show/hide conditional controls based on selected feature
        document.getElementById('featureSelect').addEventListener('change', function () {
            const feature = this.value;
            const translationLabel = document.getElementById('translationLanguageLabel');
            const translationSelect = document.getElementById('translationLanguage');
            const toneLabel = document.getElementById('replyToneLabel');
            const toneSelect = document.getElementById('replyTone');

            // Show/hide translation language selector
            if (feature === 'translate') {
                translationLabel.style.display = 'inline';
                translationSelect.style.display = 'inline';
            } else {
                translationLabel.style.display = 'none';
                translationSelect.style.display = 'none';
            }

            // Show/hide tone selector
            if (feature === 'smart_replies') {
                toneLabel.style.display = 'inline';
                toneSelect.style.display = 'inline';
            } else {
                toneLabel.style.display = 'none';
                toneSelect.style.display = 'none';
            }
        });

        async function runAIFeature() {
            const feature = document.getElementById('featureSelect').value;
            const statusEl = document.getElementById('aiStatus');
            const model = getSelectedModel();

            // Check AI state for non-summary features
            if (feature !== 'none' && feature !== 'summary' && !aiEnabled) {
                alert('AI features are currently disabled. Please enable AI to use this feature.');
                return;
            }

            if (feature === 'none') {
                alert("Please select a feature.");
                return;
            }

            if (chatMessages.length === 0) {
                alert("No messages to analyze.");
                return;
            }

            // Handle summary and tasks features directly (they open modals)
            if (feature === 'summary') {
                await generateSummary();
                return;
            }

            if (feature === 'tasks') {
                await generateTasks();
                return;
            }

            if (feature === 'translate') {
                await translateMessages();
                return;
            }

            if (feature === 'transcribe') {
                document.getElementById('transcriptionModal').style.display = 'block';
                return;
            }

            if (feature === 'reminders') {
                await generateReminderSuggestions();
                return;
            }

            // Handle other AI features (prioritize, moderate, smart_replies)
            statusEl.textContent = "Analyzing...";

            try {
                // Filter messages to only include AI-enabled ones (except for summary)
                let messagesToUse = chatMessages;
                if (feature !== 'summary') {
                    messagesToUse = chatMessages.filter(m => m.ai_enabled !== false);
                }

                // Prepare payload: List of messages
                const messagesPayload = messagesToUse.map(m => ({
                    id: m.id,
                    sender: m.sender,
                    message: m.message
                }));

                let url = `/api/features/${feature}`;
                let requestBody = {};

                if (feature === 'smart_replies') {
                    url = '/api/features/smart-replies';
                    const tone = document.getElementById('replyTone').value || 'auto';
                    requestBody = {
                        messages: messagesPayload,
                        tone: tone,
                        model: model
                    };
                } else if (feature === 'prioritize' || feature === 'moderate') {
                    // Wrap in AIAnalysisRequest structure
                    requestBody = {
                        messages: messagesPayload,
                        model: model
                    };
                } else {
                    // Fallback (shouldn't happen with current features)
                    requestBody = messagesPayload;
                }

                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    if (response.status === 403) {
                        alert(errorData.detail || 'AI features are currently disabled. Please enable AI to use this feature.');
                        statusEl.textContent = "AI features disabled";
                        statusEl.style.color = '#f44336';
                        return;
                    }
                    throw new Error(errorData.detail || 'Request failed');
                }

                const result = await response.json();
                console.log("AI Result:", result); // Debug log

                if (feature === 'prioritize') {
                    applyPriorities(result);
                } else if (feature === 'moderate') {
                    applyModeration(result);
                } else if (feature === 'smart_replies') {
                    showSmartReplies(result);
                }

                statusEl.textContent = "Analysis Complete. Check messages for tags.";

            } catch (error) {
                console.error(error);
                statusEl.textContent = "Error during analysis.";
            }
        }

        function applyPriorities(data) {
            // data format: { "msg_id": "High", ... }
            let appliedCount = 0;
            chatMessages.forEach(msg => {
                const priority = data[msg.id];
                if (priority) {
                    const tagContainer = msg.element.querySelector('.ai-tags');
                    // distinct removal
                    const oldTags = tagContainer.querySelectorAll('.tag-priority');
                    oldTags.forEach(e => e.remove());

                    let className = 'tag-normal';
                    if (priority.toLowerCase() === 'urgent') className = 'tag-urgent';
                    if (priority.toLowerCase() === 'high') className = 'tag-high';

                    // Always show the tag for clarity now
                    const span = document.createElement('span');
                    span.className = `tag ${className} tag-priority`;
                    span.textContent = priority;
                    tagContainer.appendChild(span);
                    appliedCount++;
                }
            });
            if (appliedCount === 0) alert("No priorities returned or IDs mismatch.");
        }

        function applyModeration(data) {
            // data format: { "msg_id": { "safe": false, "reason": "spam" } }
            let appliedCount = 0;
            chatMessages.forEach(msg => {
                const modResult = data[msg.id];
                if (modResult) {
                    const tagContainer = msg.element.querySelector('.ai-tags');
                    const oldTags = tagContainer.querySelectorAll('.tag-mod');
                    oldTags.forEach(e => e.remove());

                    if (!modResult.safe) {
                        const span = document.createElement('span');
                        span.className = 'tag tag-unsafe tag-mod';
                        span.title = modResult.reason || "Unsafe";
                        span.textContent = `Unsafe: ${modResult.reason || ''}`;
                        tagContainer.appendChild(span);
                    } else {
                        const span = document.createElement('span');
                        span.className = 'tag tag-safe tag-mod';
                        span.textContent = "Safe";
                        tagContainer.appendChild(span);
                    }
                    appliedCount++;
                }
            });
            if (appliedCount === 0) alert("No moderation results or IDs mismatch.");
        }

        function showSmartReplies(data) {
            // data format: { "suggestions": ["Yes", "No"] }
            // Apply to the simulation of the LAST user who received a message?
            // Usually Smart Replies are for the *current* user to reply to the *last* message.
            // Let's assume User 1 wants to reply to User 2 (or vice versa).
            // We'll show suggestions in the controls area or alert for now.
            // Better: Show a temporary "Suggestions" box in the chat center.

            const suggestions = data.suggestions;
            if (!suggestions || suggestions.length === 0) return;

            const container = document.getElementById('messages');
            const div = document.createElement('div');
            div.className = 'suggestion-box';
            div.innerHTML = `<strong>AI Suggestions:</strong><br/>`;

            suggestions.forEach(s => {
                const btn = document.createElement('button');
                btn.className = 'suggestion-btn';
                btn.textContent = s;
                btn.onclick = () => {
                    // Smartly decide which user is replying
                    // If the last message was from User 1, then User 2 is replying.
                    const lastMsg = chatMessages[chatMessages.length - 1];
                    if (lastMsg && lastMsg.sender === user1Name) {
                        document.getElementById('input2').value = s;
                    } else {
                        document.getElementById('input1').value = s;
                    }
                    div.remove();
                };
                div.appendChild(btn);
            });

            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }

        // Summary functionality
        async function generateSummary() {
            if (chatMessages.length === 0) {
                alert("No messages to summarize.");
                return;
            }

            const modal = document.getElementById('summaryModal');
            const loading = document.getElementById('summaryLoading');
            const results = document.getElementById('summaryResults');
            let model = getSelectedModel();
            let totalMessages = 100;

            if (!aiEnabled) {
                // If AI is disabled, force specific model and message count
                model = 'openai/gpt-oss-120b';
                totalMessages = 10;
                // Optional: Notify user
                // alert("AI is disabled. Generating summary using backup model (GPT OSS 120B) for last 10 messages.");
            } else {
                const totalMessagesInput = document.getElementById('summaryTotalMessages');
                totalMessages = totalMessagesInput && totalMessagesInput.value ? parseInt(totalMessagesInput.value) : 100;
            }

            modal.style.display = 'block';
            loading.style.display = 'block';
            results.innerHTML = '';

            try {
                // Use User 1 as the username for summary (or could be configurable)
                const username = user1Name;

                const requestBody = {
                    username: username,
                    total_messages: totalMessages,
                    model: model
                };

                const response = await fetch('/api/features/chat-summarize', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });
                const data = await response.json();

                if (!response.ok) {
                    const detail = data && data.detail ? data.detail : 'Server returned an error';
                    throw new Error(detail);
                }

                const summary = data.summary || 'No summary available.';
                const totalMessagesCount = typeof data.total_messages === 'number' ? data.total_messages : 0;
                const participants = Array.isArray(data.participants) ? data.participants : [];
                const bulletPoints = Array.isArray(data.bullet_points) ? data.bullet_points : [];
                const keyDecisions = Array.isArray(data.key_decisions) ? data.key_decisions : [];
                const actionItems = Array.isArray(data.action_items) ? data.action_items : [];
                const unreadSummary = data.unread_summary || 'No unread summary available.';

                loading.style.display = 'none';

                let html = `
                    <div class="summary-section">
                        <h3> Overview</h3>
                        <p>${summary}</p>
                        <p><strong>Total Messages:</strong> ${totalMessagesCount}</p>
                        <p><strong>Participants:</strong> ${participants.join(', ')}</p>
                    </div>
                    
                    <div class="summary-section">
                        <h3> What Did I Miss?</h3>
                        <p>${unreadSummary}</p>
                    </div>
                    
                    <div class="summary-section">
                        <h3> Key Points</h3>
                        <ul>
                            ${bulletPoints.map(point => `<li>${point}</li>`).join('')}
                        </ul>
                    </div>
                    
                    <div class="summary-section">
                        <h3> Key Decisions</h3>
                        <ul>
                            ${keyDecisions.map(decision => `<li>${decision}</li>`).join('')}
                        </ul>
                    </div>
                    
                    <div class="summary-section">
                        <h3> Action Items</h3>
                        <ul>
                            ${actionItems.map(action => `<li>${action}</li>`).join('')}
                        </ul>
                    </div>
                `;

                results.innerHTML = html;
            } catch (error) {
                loading.style.display = 'none';
                results.innerHTML = `<p style="color: red;">Error generating summary: ${error.message}</p>`;
            }
        }

        function closeSummary() {
            document.getElementById('summaryModal').style.display = 'none';
        }

        // Tasks classification functionality
        async function generateTasks() {
            if (chatMessages.length === 0) {
                alert("No messages to analyze for tasks.");
                return;
            }

            // Check AI state
            if (!aiEnabled) {
                alert('AI features are currently disabled. Please enable AI to use task extraction.');
                return;
            }

            const modal = document.getElementById('tasksModal');
            const loading = document.getElementById('tasksLoading');
            const results = document.getElementById('tasksResults');
            const model = getSelectedModel();

            modal.style.display = 'block';
            loading.style.display = 'block';
            results.innerHTML = '';

            try {
                // Use User 1 as the username for tasks (or could be configurable)
                const username = user1Name;
                const response = await fetch(`/api/features/tasks-classifier?username=${encodeURIComponent(username)}&model=${encodeURIComponent(model)}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });
                const data = await response.json();

                if (!response.ok) {
                    const detail = data && data.detail ? data.detail : 'Server returned an error';
                    throw new Error(detail);
                }

                const tasks = Array.isArray(data.tasks) ? data.tasks : [];
                loading.style.display = 'none';

                if (tasks.length === 0) {
                    results.innerHTML = '<p>No tasks found in the current conversation.</p>';
                    return;
                }

                const tasksHtml = tasks.map((task, index) => {
                    const title = task.title || '(untitled task)';
                    const desc = task.description || '';
                    const assignee = task.assignee || 'Unassigned';
                    const due = task.due_date || 'No deadline';
                    const status = task.status || 'todo';
                    const sourceTime = task.timestamp || '';
                    const taskId = task.id || '';

                    return `
                        <div class="summary-section" data-task-index="${index}">
                            <h3> ${escapeHtml(title)}</h3>
                            <p>${escapeHtml(desc)}</p>
                            <p><strong>Status:</strong> ${status}</p>
                            <p><strong>Assignee:</strong> ${escapeHtml(assignee)}</p>
                            <p><strong>Due date:</strong> ${due}</p>
                            ${sourceTime ? `<p><strong>From message at:</strong> ${sourceTime}</p>` : ''}
                            <button class="task-reminder-btn" data-task-id="${taskId}" data-task-title="${escapeHtml(title)}" data-task-desc="${escapeHtml(desc)}" data-task-due="${due}" data-task-assignee="${escapeHtml(assignee)}">
                                 Create Reminder
                            </button>
                        </div>
                    `;
                }).join('');

                results.innerHTML = tasksHtml;

                // Attach event listeners to reminder buttons
                results.querySelectorAll('.task-reminder-btn').forEach(btn => {
                    btn.addEventListener('click', function () {
                        const taskId = this.getAttribute('data-task-id');
                        const title = this.getAttribute('data-task-title');
                        const desc = this.getAttribute('data-task-desc');
                        const due = this.getAttribute('data-task-due');
                        const assignee = this.getAttribute('data-task-assignee');
                        createReminderFromTask(taskId, title, desc, due, assignee);
                    });
                });
            } catch (error) {
                loading.style.display = 'none';
                results.innerHTML = `<p style="color: red;">Error extracting tasks: ${error.message}</p>`;
            }
        }

        function closeTasks() {
            document.getElementById('tasksModal').style.display = 'none';
        }

        // Language translation functionality
        async function translateMessages() {
            if (chatMessages.length === 0) {
                alert("No messages to translate.");
                return;
            }

            // Check AI state
            if (!aiEnabled) {
                alert('AI features are currently disabled. Please enable AI to use translation.');
                return;
            }

            const statusEl = document.getElementById('aiStatus');
            const langSelect = document.getElementById('translationLanguage');
            const targetLang = langSelect ? langSelect.value : 'en';
            const targetLangLabel = langSelect
                ? langSelect.options[langSelect.selectedIndex].text
                : targetLang.toUpperCase();
            const model = getSelectedModel();

            statusEl.textContent = `Translating messages to ${targetLangLabel}...`;

            try {
                // Filter to only AI-enabled messages
                const aiEnabledMessages = chatMessages.filter(m => m.ai_enabled !== false);
                const payload = aiEnabledMessages.map(m => ({
                    id: m.id,
                    text: m.message,
                    target_language: targetLang,
                    model: model
                }));

                const response = await fetch('/api/features/translate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();

                if (!response.ok) {
                    const detail = data && data.detail ? data.detail : 'Server returned an error';
                    throw new Error(detail);
                }

                applyTranslations(data, targetLangLabel);
                statusEl.textContent = `Translation complete (${targetLangLabel}).`;
            } catch (error) {
                console.error(error);
                statusEl.textContent = "Error during translation.";
                alert(`Error translating messages: ${error.message}`);
            }
        }

        function applyTranslations(data, targetLangLabel) {
            const translations = data && data.translations ? data.translations : {};
            let appliedCount = 0;

            chatMessages.forEach(msg => {
                const t = translations[msg.id];
                if (t && t.translated_text) {
                    const container = msg.element;

                    // Remove any existing translation box for this message
                    const existing = container.querySelector('.translation-box');
                    if (existing) {
                        existing.remove();
                    }

                    const div = document.createElement('div');
                    div.className = 'translation-box';
                    div.innerHTML = `
                        <div class="translation-header">Translated (${targetLangLabel})</div>
                        <div class="translation-body">${escapeHtml(t.translated_text)}</div>
                    `;

                    container.appendChild(div);
                    appliedCount++;
                }
            });

            if (appliedCount === 0) {
                alert("No translations returned or IDs mismatch.");
            }
        }

        // Smart Reminders functionality
        async function generateReminderSuggestions() {
            if (chatMessages.length === 0) {
                alert("No messages to analyze for reminders.");
                return;
            }

            // Check AI state
            if (!aiEnabled) {
                alert('AI features are currently disabled. Please enable AI to use reminder suggestions.');
                return;
            }

            const modal = document.getElementById('remindersModal');
            const loading = document.getElementById('remindersLoading');
            const results = document.getElementById('remindersResults');
            const contextWindowInput = document.getElementById('reminderContextWindow');
            const model = getSelectedModel();

            modal.style.display = 'block';
            loading.style.display = 'block';
            results.innerHTML = '';

            try {
                const username = user1Name;
                const contextWindow = contextWindowInput.value ? parseInt(contextWindowInput.value) : null;

                const requestBody = {
                    username: username,
                    context_window: contextWindow,
                    model: model
                };

                const response = await fetch('/api/features/smart-reminders/suggestions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });

                const data = await response.json();

                if (!response.ok) {
                    const detail = data && data.detail ? data.detail : 'Server returned an error';
                    throw new Error(detail);
                }

                const suggestions = Array.isArray(data.suggestions) ? data.suggestions : [];
                loading.style.display = 'none';

                if (suggestions.length === 0) {
                    results.innerHTML = '<p>No reminder suggestions found. Try having more conversations with action items or deadlines.</p>';
                    return;
                }

                const suggestionsHtml = suggestions.map(suggestion => {
                    const id = suggestion.id || '';
                    const title = suggestion.title || '(untitled)';
                    const desc = suggestion.description || '';
                    const dueDate = suggestion.suggested_due_date || 'No deadline';
                    const priority = (suggestion.priority || 'medium').toLowerCase();
                    const context = suggestion.context || '';
                    const confidence = suggestion.confidence || 0;

                    const priorityClass = `priority-${priority}`;
                    const priorityLabel = priority.charAt(0).toUpperCase() + priority.slice(1);

                    return `
                        <div class="reminder-suggestion" data-suggestion-id="${id}">
                            <h4>${escapeHtml(title)}</h4>
                            <p>${escapeHtml(desc)}</p>
                            ${context ? `<p class="reminder-meta"><em>"${escapeHtml(context)}"</em></p>` : ''}
                            <div class="reminder-meta">
                                <span class="reminder-priority ${priorityClass}">${priorityLabel}</span>
                                <span>Due: ${dueDate}</span>
                                <span style="margin-left: 10px;">Confidence: ${(confidence * 100).toFixed(0)}%</span>
                            </div>
                            <div class="reminder-actions">
                                <button class="btn-create-reminder" data-suggestion-id="${id}" data-suggestion-title="${escapeHtml(title)}" data-suggestion-desc="${escapeHtml(desc)}" data-suggestion-due="${dueDate}">
                                    Create Reminder
                                </button>
                            </div>
                        </div>
                    `;
                }).join('');

                results.innerHTML = suggestionsHtml;

                // Attach event listeners to reminder creation buttons
                results.querySelectorAll('.btn-create-reminder').forEach(btn => {
                    btn.addEventListener('click', function () {
                        const id = this.getAttribute('data-suggestion-id');
                        const title = this.getAttribute('data-suggestion-title');
                        const desc = this.getAttribute('data-suggestion-desc');
                        const dueDate = this.getAttribute('data-suggestion-due');
                        createReminderFromSuggestion(id, title, desc, dueDate, null);
                    });
                });
            } catch (error) {
                loading.style.display = 'none';
                results.innerHTML = `<p style="color: red;">Error generating reminder suggestions: ${error.message}</p>`;
            }
        }

        function closeReminders() {
            document.getElementById('remindersModal').style.display = 'none';
        }

        async function createReminderFromSuggestion(suggestionId, title, description, dueDate, assignee) {
            try {
                const requestBody = {
                    task_id: suggestionId,
                    title: title,
                    description: description || null,
                    due_date: dueDate !== 'No deadline' ? dueDate : null,
                    assignee: assignee || null,
                    reminder_time: null
                };

                const response = await fetch('/api/features/smart-reminders/create', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });

                const data = await response.json();

                if (!response.ok) {
                    const detail = data && data.detail ? data.detail : 'Server returned an error';
                    throw new Error(detail);
                }

                // Show success message
                const results = document.getElementById('remindersResults');
                const successMsg = document.createElement('div');
                successMsg.className = 'reminder-created';
                successMsg.innerHTML = `
                    <strong> Reminder Created!</strong>
                    <p><strong>Title:</strong> ${data.title}</p>
                    ${data.due_date ? `<p><strong>Due Date:</strong> ${data.due_date}</p>` : ''}
                    ${data.reminder_time ? `<p><strong>Reminder Time:</strong> ${new Date(data.reminder_time).toLocaleString()}</p>` : ''}
                    <p><strong>Status:</strong> ${data.status}</p>
                `;
                results.insertBefore(successMsg, results.firstChild);

                // Remove the suggestion from the list
                const suggestionElement = results.querySelector(`[data-suggestion-id="${suggestionId}"]`);
                if (suggestionElement) {
                    // Add a fade-out animation before removing
                    suggestionElement.style.transition = 'opacity 0.3s ease-out';
                    suggestionElement.style.opacity = '0';
                    setTimeout(() => {
                        suggestionElement.remove();

                        // If no suggestions remain, show a message
                        const remainingSuggestions = results.querySelectorAll('.reminder-suggestion');
                        if (remainingSuggestions.length === 0) {
                            results.innerHTML = '<p>All reminders have been created. No more suggestions available.</p>';
                        }
                    }, 300);
                }

                // Scroll to top to show the success message
                results.scrollTop = 0;

                // Remove success message after 5 seconds
                setTimeout(() => {
                    successMsg.remove();
                }, 5000);

            } catch (error) {
                alert(`Error creating reminder: ${error.message}`);
            }
        }

        async function createReminderFromTask(taskId, title, description, dueDate, assignee) {
            try {
                const requestBody = {
                    task_id: taskId,
                    title: title,
                    description: description || null,
                    due_date: dueDate !== 'No deadline' ? dueDate : null,
                    assignee: assignee !== 'Unassigned' ? assignee : null,
                    reminder_time: null
                };

                const response = await fetch('/api/features/smart-reminders/create', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });

                const data = await response.json();

                if (!response.ok) {
                    const detail = data && data.detail ? data.detail : 'Server returned an error';
                    throw new Error(detail);
                }

                // Show success message in tasks modal
                const results = document.getElementById('tasksResults');
                const successMsg = document.createElement('div');
                successMsg.className = 'reminder-created';
                successMsg.innerHTML = `
                    <strong> Reminder Created from Task!</strong>
                    <p><strong>Title:</strong> ${data.title}</p>
                    ${data.due_date ? `<p><strong>Due Date:</strong> ${data.due_date}</p>` : ''}
                    ${data.reminder_time ? `<p><strong>Reminder Time:</strong> ${new Date(data.reminder_time).toLocaleString()}</p>` : ''}
                    <p><strong>Status:</strong> ${data.status}</p>
                `;
                results.insertBefore(successMsg, results.firstChild);

                // Scroll to top to show the success message
                results.scrollTop = 0;

                // Remove success message after 5 seconds
                setTimeout(() => {
                    successMsg.remove();
                }, 5000);

            } catch (error) {
                alert(`Error creating reminder: ${error.message}`);
            }
        }

        // Close modal when clicking outside
        // Transcription functionality
        async function uploadForTranscription() {
            const fileInput = document.getElementById('audioInput');
            const file = fileInput.files[0];

            if (!file) {
                alert("Please select an audio file first.");
                return;
            }

            const loading = document.getElementById('transcriptionLoading');
            const results = document.getElementById('transcriptionResults');

            loading.style.display = 'block';
            results.textContent = '';

            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/api/features/transcribe', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                loading.style.display = 'none';

                if (!response.ok) {
                    throw new Error(data.detail || 'Transcription failed');
                }

                results.textContent = data.transcription;

                // Show the actions area (Summary + Translate)
                document.getElementById('transcriptionActions').style.display = 'block';

            } catch (error) {
                loading.style.display = 'none';
                results.innerHTML = `<span style="color:red">Error: ${error.message}</span>`;
            }
        }

        async function generateTranscriptSummary() {
            const transcriptText = document.getElementById('transcriptionResults').textContent;
            if (!transcriptText) return;

            const results = document.getElementById('transcriptionSummaryResult');
            const model = getSelectedModel();

            // Show loading state directly in the result div
            results.innerHTML = '<div style="text-align:center; padding:10px;">Generating summary...</div>';

            try {
                const response = await fetch('/api/features/summarize-text', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: transcriptText, model: model })
                });

                const data = await response.json();

                let html = `
                    <div class="summary-section">
                        <h3> Overview</h3>
                        <p>${data.summary}</p>
                    </div>
                    
                    <div class="summary-section">
                        <h3> Key Points</h3>
                        <ul>
                            ${data.bullet_points.map(p => `<li>${p}</li>`).join('')}
                        </ul>
                    </div>

                    <div class="summary-section">
                        <h3> Key Decisions</h3>
                        <ul>
                            ${data.key_decisions.map(d => `<li>${d}</li>`).join('')}
                        </ul>
                    </div>

                    <div class="summary-section">
                        <h3> Action Items</h3>
                        <ul>
                            ${data.action_items.map(a => `<li>${a}</li>`).join('')}
                        </ul>
                    </div>
                `;
                results.innerHTML = html;

            } catch (error) {
                results.innerHTML = `<p style="color:red">Error generating summary: ${error.message}</p>`;
            }
        }

        async function translateTranscript() {
            const transcriptText = document.getElementById('transcriptionResults').textContent;
            if (!transcriptText) return;

            const langSelect = document.getElementById('transcriptLangSelect');
            const targetLang = langSelect.value;
            const targetLangLabel = langSelect.options[langSelect.selectedIndex].text;
            const results = document.getElementById('transcriptionTranslationResult');
            const model = getSelectedModel();

            // Show loading state
            results.innerHTML = `<div style="text-align:center; padding:10px;">Translating to ${targetLangLabel}...</div>`;

            try {
                const response = await fetch('/api/features/translate-text', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: transcriptText,
                        target_language: targetLang,
                        model: model
                    })
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.detail || 'Translation failed');
                }

                let html = `
                    <div class="summary-section">
                        <h3> Translation (${targetLangLabel})</h3>
                        <p style="white-space: pre-wrap;">${escapeHtml(data.translated_text)}</p>
                        <p><small>Detected Language: ${data.detected_language}</small></p>
                    </div>
                `;
                results.innerHTML = html;

            } catch (error) {
                results.innerHTML = `<p style="color:red">Error translation: ${error.message}</p>`;
            }
        }

        function closeTranscription() {
            document.getElementById('transcriptionModal').style.display = 'none';
        }

        // Close modal when clicking outside
        window.onclick = function (event) {
            const summaryModal = document.getElementById('summaryModal');
            const tasksModal = document.getElementById('tasksModal');
            const remindersModal = document.getElementById('remindersModal');
            const transcriptionModal = document.getElementById('transcriptionModal');

            if (event.target == summaryModal) summaryModal.style.display = 'none';
            if (event.target == tasksModal) tasksModal.style.display = 'none';
            if (event.target == remindersModal) remindersModal.style.display = 'none';
            if (event.target == transcriptionModal) transcriptionModal.style.display = 'none';
        }

        // Auto-translate message based on receiving user's language preference
        async function autoTranslateMessage(messageObj) {
            const isUser1Sender = messageObj.sender === user1Name;
            const receivingUser = isUser1Sender ? 'user2' : 'user1';
            const receivingUserName = isUser1Sender ? user2Name : user1Name;
            const langSelect = document.getElementById(`${receivingUser}Language`);

            if (!langSelect || !langSelect.value) {
                return; // No language selected for receiving user
            }

            const targetLang = langSelect.value;
            const targetLangLabel = langSelect.options[langSelect.selectedIndex].text;

            // Check if AI is still enabled
            if (!aiEnabled) {
                return;
            }

            try {
                const model = getSelectedModel();
                const payload = [{
                    id: messageObj.id,
                    text: messageObj.message,
                    target_language: targetLang,
                    model: model
                }];

                const response = await fetch('/api/features/translate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    // Silently fail for auto-translation
                    return;
                }

                const data = await response.json();
                const translations = data && data.translations ? data.translations : {};
                const translation = translations[messageObj.id];

                if (translation && translation.translated_text) {
                    // Remove any existing auto-translation for this message
                    const existing = messageObj.element.querySelector('.auto-translation-box');
                    if (existing) {
                        existing.remove();
                    }

                    const translationDiv = document.createElement('div');
                    translationDiv.className = 'auto-translation-box';
                    translationDiv.innerHTML = `
                        <div class="translation-header">${receivingUserName} (${targetLangLabel})</div>
                        <div class="translation-body">${escapeHtml(translation.translated_text)}</div>
                    `;

                    messageObj.element.appendChild(translationDiv);
                }
            } catch (error) {
                // Silently fail for auto-translation
                console.error('Auto-translation error:', error);
            }
        }

        // Retranslate all messages from a specific sender for a receiving user
        async function retranslateMessagesForUser(senderName, receivingUser) {
            const langSelect = document.getElementById(`${receivingUser}Language`);
            if (!langSelect || !langSelect.value || !aiEnabled) {
                return;
            }

            // senderName is the user who sent the messages (user1 or user2)
            // receivingUser is the user who wants to see translations (user1 or user2)
            const sender = senderName === 'user1' ? user1Name : user2Name;
            const messagesToTranslate = chatMessages.filter(m =>
                m.sender === sender &&
                m.ai_enabled !== false
            );

            for (const msg of messagesToTranslate) {
                await autoTranslateMessage(msg);
            }
        }

        // Remove all auto-translations for a specific user
        function removeAutoTranslationsForUser(receivingUser) {
            // receivingUser is user1 or user2 - we need to remove translations
            // for messages that were translated TO this user's language preference
            // So if receivingUser is user1, we remove translations from messages sent by user2
            // If receivingUser is user2, we remove translations from messages sent by user1
            const sender = receivingUser === 'user1' ? user2Name : user1Name;
            const messagesFromSender = chatMessages.filter(m => m.sender === sender);

            messagesFromSender.forEach(msg => {
                const existing = msg.element.querySelector('.auto-translation-box');
                if (existing) {
                    existing.remove();
                }
            });
        }

        // Initialize AI status and connect
        initializeAIStatus();
        connect();

        // Add event listener for AI toggle
        document.getElementById('aiToggle').addEventListener('change', toggleAI);

        // Helper to get selected model (enforcing one model as requested)
        function getSelectedModel() {
            // User requested to force this model for all services, 
            // while keeping the UI list visible.
            return "openai/gpt-oss-120b";
        }





        // Add event listeners for language selection changes
        document.getElementById('user1Language').addEventListener('change', function () {
            if (aiEnabled && this.value) {
                // Re-translate all messages from User 2
                retranslateMessagesForUser('user2', 'user1');
            } else {
                // Remove all auto-translations for User 1
                removeAutoTranslationsForUser('user1');
            }
        });

        document.getElementById('user2Language').addEventListener('change', function () {
            if (aiEnabled && this.value) {
                // Re-translate all messages from User 1
                retranslateMessagesForUser('user1', 'user2');
            } else {
                // Remove all auto-translations for User 2
                removeAutoTranslationsForUser('user2');
            }
        });

    </script>
</body>

</html>