<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dual-User AI Chat</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
            height: 100vh;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }

        .main-container {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            /* User 1 | Chat | User 2 */
            gap: 20px;
            flex: 1;
            min-height: 0;
            /* Important for scroll */
        }

        .user-panel {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .user-panel h2 {
            border-bottom: 2px solid #ddd;
            padding-bottom: 10px;
            margin-top: 0;
            text-align: center;
        }

        .user-1-panel h2 {
            border-color: #2196F3;
            color: #2196F3;
        }

        .user-2-panel h2 {
            border-color: #E91E63;
            color: #E91E63;
        }

        .chat-container {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        #messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .message {
            max-width: 80%;
            padding: 10px 15px;
            border-radius: 15px;
            position: relative;
            word-wrap: break-word;
        }

        .message.left {
            align-self: flex-start;
            background-color: #e3f2fd;
            /* Light Blue */
            color: #0d47a1;
            border-bottom-left-radius: 2px;
        }

        .message.right {
            align-self: flex-end;
            background-color: #fce4ec;
            /* Light Pink */
            color: #880e4f;
            border-bottom-right-radius: 2px;
        }

        .message-header {
            font-size: 0.75em;
            margin-bottom: 5px;
            opacity: 0.7;
            font-weight: bold;
        }

        .controls {
            padding: 15px;
            background: #f9f9f9;
            border-top: 1px solid #eee;
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
        }

        textarea {
            width: 100%;
            resize: vertical;
            min-height: 80px;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            font-family: inherit;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        button.send-btn {
            width: 100%;
        }

        .btn-user1 {
            background-color: #2196F3;
            color: white;
        }

        .btn-user1:hover {
            background-color: #1976D2;
        }

        .btn-user2 {
            background-color: #E91E63;
            color: white;
        }

        .btn-user2:hover {
            background-color: #C2185B;
        }

        .btn-ai {
            background-color: #6200ea;
            /* Deep Purple */
            color: white;
        }

        .btn-ai:hover {
            background-color: #3700b3;
        }

        select {
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            flex: 1;
        }

        /* AI Metadata Styles */
        .tag {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.75em;
            margin-left: 5px;
            font-weight: bold;
        }

        .tag-urgent {
            background: #ff5252;
            color: white;
        }

        .tag-high {
            background: #ff9100;
            color: white;
        }

        .tag-normal {
            background: #bbb;
            color: white;
        }

        .tag-safe {
            background: #4caf50;
            color: white;
        }

        .tag-unsafe {
            background: #f44336;
            color: white;
        }

        .suggestion-box {
            background: #fff3e0;
            padding: 10px;
            margin-top: 5px;
            border-left: 3px solid #ff9800;
            font-size: 0.9em;
        }

        .suggestion-btn {
            background: white;
            border: 1px solid #ff9800;
            color: #bf360c;
            padding: 3px 8px;
            margin: 2px;
            cursor: pointer;
            font-size: 0.85em;
        }

        /* Summary and Tasks Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            border-radius: 10px;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: black;
        }

        .summary-section {
            margin: 20px 0;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 5px;
        }

        .summary-section h3 {
            margin-top: 0;
            color: #2196F3;
        }

        .summary-section ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .summary-section li {
            margin: 5px 0;
        }
    </style>
</head>

<body>

    <h1>Dual-User Simulation & AI Features</h1>

    <div class="main-container">
        <!-- USER 1 PANEL -->
        <div class="user-panel user-1-panel">
            <h2>User 1</h2>
            <textarea id="input1" placeholder="Type as User 1..."></textarea>
            <button class="send-btn btn-user1" onclick="sendUser1()">Send >></button>
            <div id="status1" style="font-size:0.8em; color:gray; text-align:center;">Disconnected</div>
        </div>

        <!-- CENTER CHAT AREA -->
        <div class="chat-container">
            <div id="messages"></div>

            <!-- AI CONTROLS -->
            <div class="controls">
                <label for="featureSelect"><strong>AI Feature:</strong></label>
                <select id="featureSelect">
                    <option value="none">-- Select Feature --</option>
                    <option value="prioritize">Message Prioritization</option>
                    <option value="moderate">AI Moderation</option>
                    <option value="smart_replies">Smart Replies</option>
                    <option value="summary">üìä Chat Summary</option>
                    <option value="tasks">‚úÖ Extract Tasks</option>
                </select>
                <button class="btn-ai" onclick="runAIFeature()">Run Analysis</button>
            </div>
            <div id="aiStatus" style="font-size:0.8em; color:gray; text-align:center; padding-bottom: 5px;">Ready</div>
        </div>

        <!-- USER 2 PANEL -->
        <div class="user-panel user-2-panel">
            <h2>User 2</h2>
            <textarea id="input2" placeholder="Type as User 2..."></textarea>
            <button class="send-btn btn-user2" onclick="sendUser2()">
                << Send</button>
                    <div id="status2" style="font-size:0.8em; color:gray; text-align:center;">Disconnected</div>
        </div>
    </div>

    <!-- Summary Modal -->
    <div id="summaryModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeSummary()">&times;</span>
            <h2>Chat Summary</h2>
            <div id="summaryLoading" style="display: none; text-align: center; padding: 20px;">Generating summary...</div>
            <div id="summaryResults"></div>
        </div>
    </div>

    <!-- Tasks Modal -->
    <div id="tasksModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeTasks()">&times;</span>
            <h2>Chat Tasks / To-Dos</h2>
            <div id="tasksLoading" style="display: none; text-align: center; padding: 20px;">Extracting tasks...</div>
            <div id="tasksResults"></div>
        </div>
    </div>

    <script>
        // --- WebSocket Setup ---
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const host = window.location.host;

        let ws1, ws2;
        const user1Name = "User 1";
        const user2Name = "User 2";

        // Global store for messages to easily update UI
        let chatMessages = [];

        function connect() {
            // Connect User 1
            ws1 = new WebSocket(`${protocol}//${host}/ws?username=${encodeURIComponent(user1Name)}`);
            ws1.onopen = () => updateStatus('status1', 'Connected (Online)', 'green');
            ws1.onclose = () => updateStatus('status1', 'Disconnected', 'red');
            ws1.onmessage = (e) => handleMessage(e);

            // Connect User 2
            ws2 = new WebSocket(`${protocol}//${host}/ws?username=${encodeURIComponent(user2Name)}`);
            ws2.onopen = () => updateStatus('status2', 'Connected (Online)', 'green');
            ws2.onclose = () => updateStatus('status2', 'Disconnected', 'red');
            ws2.onmessage = (e) => handleMessage(e); // Both listen, but backend broadcasts to all
        }

        function updateStatus(elemId, text, color) {
            const el = document.getElementById(elemId);
            el.textContent = text;
            el.style.color = color;
        }

        // Handle incoming messages
        function handleMessage(event) {
            const data = JSON.parse(event.data);

            // We only care about actual 'message' types to display in the main chat
            // Dual connection means we might receive duplicates if we aren't careful, 
            // but the backend `exclude_user_id` logic usually handles "echo".
            // However, since we have ONE UI showing ALL messages, we need to be careful.
            // Simplified: The backend broadcasts to everyone except sender.
            // BUT, our UI needs to show the sender's own message too immediately?
            // Actually, best pattern: Sender adds locally, others receive via WS.
            // OR: Backend broadcasts to EVERYONE including sender (simpler for state sync).

            // In the provided `main.py`, it uses `exclude_user_id`.
            // So User 1 sends -> Backend -> User 2 receives.
            // User 1 needs to see their own message. 
            // We'll handle "own message" display in the send function for immediate feedback,
            // OR better: we utilize the existing logic.
            // Let's just listen. User 1 sends. User 2 receives. 
            // Since this is a "Central View", we should just append messages as they come In.
            // Problem: ws1.onmessage only gets messages from OTHERS (User 2).
            // ws2.onmessage only gets messages from OTHERS (User 1).
            // So if User 1 sends, ws2 receives it. We display it.
            // If User 2 sends, ws1 receives it. We display it.
            // Perfect!

            if (data.type === 'message') {
                displayMessage(data);
            }
        }

        function displayMessage(msgData) {
            // Avoid duplicates if both sockets receive notifications (e.g. system messages)
            // For simple chat messages between 2 people, it's distinct.

            const container = document.getElementById('messages');
            const div = document.createElement('div');

            const isUser1 = msgData.sender === user1Name;
            div.className = `message ${isUser1 ? 'left' : 'right'}`;
            div.dataset.id = msgData.message_id || Date.now(); // Ensure ID exists for AI features

            div.innerHTML = `
                <div class="message-header">${msgData.sender}</div>
                <div class="message-body">${msgData.message}</div>
                <div class="ai-tags"></div>
            `;

            container.appendChild(div);
            container.scrollTop = container.scrollHeight;

            // Keep track for AI analysis
            chatMessages.push({
                id: div.dataset.id,
                sender: msgData.sender,
                message: msgData.message,
                element: div
            });
        }

        function sendUser1() {
            const input = document.getElementById('input1');
            const text = input.value.trim();
            if (!text) return;

            // Send via WS - Do NOT display locally, wait for WS echo/broadcast to other user
            // Since we have both User 1 and User 2 sockets open:
            // User 1 sends -> Backend -> User 2 receives -> We display from User 2's socket event.
            ws1.send(JSON.stringify({ message: text }));

            input.value = '';
        }

        function sendUser2() {
            const input = document.getElementById('input2');
            const text = input.value.trim();
            if (!text) return;

            // Send via WS
            ws2.send(JSON.stringify({ message: text }));

            input.value = '';
        }

        // --- AI Features ---

        async function runAIFeature() {
            const feature = document.getElementById('featureSelect').value;
            const statusEl = document.getElementById('aiStatus');

            if (feature === 'none') {
                alert("Please select a feature.");
                return;
            }

            if (chatMessages.length === 0) {
                alert("No messages to analyze.");
                return;
            }

            // Handle summary and tasks features directly (they open modals)
            if (feature === 'summary') {
                await generateSummary();
                return;
            }

            if (feature === 'tasks') {
                await generateTasks();
                return;
            }

            // Handle other AI features (prioritize, moderate, smart_replies)
            statusEl.textContent = "Analyzing...";

            try {
                // Prepare payload: List of messages
                const payload = chatMessages.map(m => ({
                    id: m.id,
                    sender: m.sender,
                    message: m.message
                }));

                let url = `/api/features/${feature}`;
                if (feature === 'smart_replies') url = '/api/features/smart-replies';

                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                console.log("AI Result:", result); // Debug log

                if (feature === 'prioritize') {
                    applyPriorities(result);
                } else if (feature === 'moderate') {
                    applyModeration(result);
                } else if (feature === 'smart_replies') {
                    showSmartReplies(result);
                }

                statusEl.textContent = "Analysis Complete. Check messages for tags.";

            } catch (error) {
                console.error(error);
                statusEl.textContent = "Error during analysis.";
            }
        }

        function applyPriorities(data) {
            // data format: { "msg_id": "High", ... }
            let appliedCount = 0;
            chatMessages.forEach(msg => {
                const priority = data[msg.id];
                if (priority) {
                    const tagContainer = msg.element.querySelector('.ai-tags');
                    // distinct removal
                    const oldTags = tagContainer.querySelectorAll('.tag-priority');
                    oldTags.forEach(e => e.remove());

                    let className = 'tag-normal';
                    if (priority.toLowerCase() === 'urgent') className = 'tag-urgent';
                    if (priority.toLowerCase() === 'high') className = 'tag-high';

                    // Always show the tag for clarity now
                    const span = document.createElement('span');
                    span.className = `tag ${className} tag-priority`;
                    span.textContent = priority;
                    tagContainer.appendChild(span);
                    appliedCount++;
                }
            });
            if (appliedCount === 0) alert("No priorities returned or IDs mismatch.");
        }

        function applyModeration(data) {
            // data format: { "msg_id": { "safe": false, "reason": "spam" } }
            let appliedCount = 0;
            chatMessages.forEach(msg => {
                const modResult = data[msg.id];
                if (modResult) {
                    const tagContainer = msg.element.querySelector('.ai-tags');
                    const oldTags = tagContainer.querySelectorAll('.tag-mod');
                    oldTags.forEach(e => e.remove());

                    if (!modResult.safe) {
                        const span = document.createElement('span');
                        span.className = 'tag tag-unsafe tag-mod';
                        span.title = modResult.reason || "Unsafe";
                        span.textContent = `Unsafe: ${modResult.reason || ''}`;
                        tagContainer.appendChild(span);
                    } else {
                        const span = document.createElement('span');
                        span.className = 'tag tag-safe tag-mod';
                        span.textContent = "Safe";
                        tagContainer.appendChild(span);
                    }
                    appliedCount++;
                }
            });
            if (appliedCount === 0) alert("No moderation results or IDs mismatch.");
        }

        function showSmartReplies(data) {
            // data format: { "suggestions": ["Yes", "No"] }
            // Apply to the simulation of the LAST user who received a message?
            // Usually Smart Replies are for the *current* user to reply to the *last* message.
            // Let's assume User 1 wants to reply to User 2 (or vice versa).
            // We'll show suggestions in the controls area or alert for now.
            // Better: Show a temporary "Suggestions" box in the chat center.

            const suggestions = data.suggestions;
            if (!suggestions || suggestions.length === 0) return;

            const container = document.getElementById('messages');
            const div = document.createElement('div');
            div.className = 'suggestion-box';
            div.innerHTML = `<strong>AI Suggestions:</strong><br/>`;

            suggestions.forEach(s => {
                const btn = document.createElement('button');
                btn.className = 'suggestion-btn';
                btn.textContent = s;
                btn.onclick = () => {
                    // Start typing in User 1 or 2 box?
                    // Let's just put it in BOTH input boxes as a "Draft"
                    document.getElementById('input1').value = s;
                    document.getElementById('input2').value = s;
                    div.remove();
                };
                div.appendChild(btn);
            });

            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }

        // Summary functionality
        async function generateSummary() {
            if (chatMessages.length === 0) {
                alert("No messages to summarize.");
                return;
            }

            const modal = document.getElementById('summaryModal');
            const loading = document.getElementById('summaryLoading');
            const results = document.getElementById('summaryResults');
            
            modal.style.display = 'block';
            loading.style.display = 'block';
            results.innerHTML = '';

            try {
                // Use User 1 as the username for summary (or could be configurable)
                const username = user1Name;
                const response = await fetch(`/api/summarize?username=${encodeURIComponent(username)}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });
                const data = await response.json();

                if (!response.ok) {
                    const detail = data && data.detail ? data.detail : 'Server returned an error';
                    throw new Error(detail);
                }

                const summary = data.summary || 'No summary available.';
                const totalMessages = typeof data.total_messages === 'number' ? data.total_messages : 0;
                const participants = Array.isArray(data.participants) ? data.participants : [];
                const bulletPoints = Array.isArray(data.bullet_points) ? data.bullet_points : [];
                const keyDecisions = Array.isArray(data.key_decisions) ? data.key_decisions : [];
                const actionItems = Array.isArray(data.action_items) ? data.action_items : [];
                const unreadSummary = data.unread_summary || 'No unread summary available.';
                
                loading.style.display = 'none';
                
                let html = `
                    <div class="summary-section">
                        <h3>üìã Overview</h3>
                        <p>${summary}</p>
                        <p><strong>Total Messages:</strong> ${totalMessages}</p>
                        <p><strong>Participants:</strong> ${participants.join(', ')}</p>
                    </div>
                    
                    <div class="summary-section">
                        <h3>üí¨ What Did I Miss?</h3>
                        <p>${unreadSummary}</p>
                    </div>
                    
                    <div class="summary-section">
                        <h3>üìù Key Points</h3>
                        <ul>
                            ${bulletPoints.map(point => `<li>${point}</li>`).join('')}
                        </ul>
                    </div>
                    
                    <div class="summary-section">
                        <h3>‚úÖ Key Decisions</h3>
                        <ul>
                            ${keyDecisions.map(decision => `<li>${decision}</li>`).join('')}
                        </ul>
                    </div>
                    
                    <div class="summary-section">
                        <h3>üéØ Action Items</h3>
                        <ul>
                            ${actionItems.map(action => `<li>${action}</li>`).join('')}
                        </ul>
                    </div>
                `;
                
                results.innerHTML = html;
            } catch (error) {
                loading.style.display = 'none';
                results.innerHTML = `<p style="color: red;">Error generating summary: ${error.message}</p>`;
            }
        }

        function closeSummary() {
            document.getElementById('summaryModal').style.display = 'none';
        }

        // Tasks classification functionality
        async function generateTasks() {
            if (chatMessages.length === 0) {
                alert("No messages to analyze for tasks.");
                return;
            }

            const modal = document.getElementById('tasksModal');
            const loading = document.getElementById('tasksLoading');
            const results = document.getElementById('tasksResults');

            modal.style.display = 'block';
            loading.style.display = 'block';
            results.innerHTML = '';

            try {
                // Use User 1 as the username for tasks (or could be configurable)
                const username = user1Name;
                const response = await fetch(`/api/tasks?username=${encodeURIComponent(username)}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });
                const data = await response.json();

                if (!response.ok) {
                    const detail = data && data.detail ? data.detail : 'Server returned an error';
                    throw new Error(detail);
                }

                const tasks = Array.isArray(data.tasks) ? data.tasks : [];
                loading.style.display = 'none';

                if (tasks.length === 0) {
                    results.innerHTML = '<p>No tasks found in the current conversation.</p>';
                    return;
                }

                const tasksHtml = tasks.map(task => {
                    const title = task.title || '(untitled task)';
                    const desc = task.description || '';
                    const assignee = task.assignee || 'Unassigned';
                    const due = task.due_date || 'No deadline';
                    const status = task.status || 'todo';
                    const sourceTime = task.timestamp || '';

                    return `
                        <div class="summary-section">
                            <h3>üìù ${title}</h3>
                            <p>${desc}</p>
                            <p><strong>Status:</strong> ${status}</p>
                            <p><strong>Assignee:</strong> ${assignee}</p>
                            <p><strong>Due date:</strong> ${due}</p>
                            ${sourceTime ? `<p><strong>From message at:</strong> ${sourceTime}</p>` : ''}
                        </div>
                    `;
                }).join('');

                results.innerHTML = tasksHtml;
            } catch (error) {
                loading.style.display = 'none';
                results.innerHTML = `<p style="color: red;">Error extracting tasks: ${error.message}</p>`;
            }
        }

        function closeTasks() {
            document.getElementById('tasksModal').style.display = 'none';
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const summaryModal = document.getElementById('summaryModal');
            const tasksModal = document.getElementById('tasksModal');
            if (event.target == summaryModal) {
                summaryModal.style.display = 'none';
            } else if (event.target == tasksModal) {
                tasksModal.style.display = 'none';
            }
        }

        // Initial Connect
        connect();

    </script>
</body>

</html>