<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dual-User AI Chat</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
            height: 100vh;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }

        .main-container {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            /* User 1 | Chat | User 2 */
            gap: 20px;
            flex: 1;
            min-height: 0;
            /* Important for scroll */
        }

        .user-panel {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .user-panel h2 {
            border-bottom: 2px solid #ddd;
            padding-bottom: 10px;
            margin-top: 0;
            text-align: center;
        }

        .user-1-panel h2 {
            border-color: #2196F3;
            color: #2196F3;
        }

        .user-2-panel h2 {
            border-color: #E91E63;
            color: #E91E63;
        }

        .chat-container {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        #messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .message {
            max-width: 80%;
            padding: 10px 15px;
            border-radius: 15px;
            position: relative;
            word-wrap: break-word;
        }

        .message.left {
            align-self: flex-start;
            background-color: #e3f2fd;
            /* Light Blue */
            color: #0d47a1;
            border-bottom-left-radius: 2px;
        }

        .message.right {
            align-self: flex-end;
            background-color: #fce4ec;
            /* Light Pink */
            color: #880e4f;
            border-bottom-right-radius: 2px;
        }

        .message-header {
            font-size: 0.75em;
            margin-bottom: 5px;
            opacity: 0.7;
            font-weight: bold;
        }

        .controls {
            padding: 15px;
            background: #f9f9f9;
            border-top: 1px solid #eee;
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
        }

        textarea {
            width: 100%;
            resize: vertical;
            min-height: 80px;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            font-family: inherit;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        button.send-btn {
            width: 100%;
        }

        .btn-user1 {
            background-color: #2196F3;
            color: white;
        }

        .btn-user1:hover {
            background-color: #1976D2;
        }

        .btn-user2 {
            background-color: #E91E63;
            color: white;
        }

        .btn-user2:hover {
            background-color: #C2185B;
        }

        .btn-ai {
            background-color: #6200ea;
            /* Deep Purple */
            color: white;
        }

        .btn-ai:hover {
            background-color: #3700b3;
        }

        select {
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            flex: 1;
        }

        /* AI Metadata Styles */
        .tag {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.75em;
            margin-left: 5px;
            font-weight: bold;
        }

        .tag-urgent {
            background: #ff5252;
            color: white;
        }

        .tag-high {
            background: #ff9100;
            color: white;
        }

        .tag-normal {
            background: #bbb;
            color: white;
        }

        .tag-safe {
            background: #4caf50;
            color: white;
        }

        .tag-unsafe {
            background: #f44336;
            color: white;
        }

        .suggestion-box {
            background: #fff3e0;
            padding: 10px;
            margin-top: 5px;
            border-left: 3px solid #ff9800;
            font-size: 0.9em;
        }

        .suggestion-btn {
            background: white;
            border: 1px solid #ff9800;
            color: #bf360c;
            padding: 3px 8px;
            margin: 2px;
            cursor: pointer;
            font-size: 0.85em;
        }

        /* Summary and Tasks Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            border-radius: 10px;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: black;
        }

        .summary-section {
            margin: 20px 0;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 5px;
        }

        .summary-section h3 {
            margin-top: 0;
            color: #2196F3;
        }

        .summary-section ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .summary-section li {
            margin: 5px 0;
        }

        /* Reminder Styles */
        .reminder-suggestion {
            background: #f0f7ff;
            border: 1px solid #2196F3;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            cursor: pointer;
            transition: background 0.2s;
        }

        .reminder-suggestion:hover {
            background: #e3f2fd;
        }

        .reminder-suggestion h4 {
            margin: 0 0 8px 0;
            color: #1976D2;
        }

        .reminder-meta {
            font-size: 0.85em;
            color: #666;
            margin: 5px 0;
        }

        .reminder-priority {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: bold;
            margin-right: 8px;
        }

        .priority-high {
            background: #ff5252;
            color: white;
        }

        .priority-medium {
            background: #ff9800;
            color: white;
        }

        .priority-low {
            background: #9e9e9e;
            color: white;
        }

        .reminder-actions {
            margin-top: 10px;
            display: flex;
            gap: 8px;
        }

        .btn-create-reminder {
            background: #4caf50;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
        }

        .btn-create-reminder:hover {
            background: #45a049;
        }

        .reminder-created {
            background: #e8f5e9;
            border: 1px solid #4caf50;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .task-reminder-btn {
            background: #2196F3;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            margin-top: 8px;
        }

        .task-reminder-btn:hover {
            background: #1976D2;
        }

        /* Translation styles */
        .translation-box {
            margin-top: 8px;
            padding: 8px 10px;
            border-radius: 8px;
            background: #f1f8e9;
            border-left: 3px solid #8bc34a;
            font-size: 0.9em;
        }

        .translation-header {
            font-weight: bold;
            color: #558b2f;
            margin-bottom: 4px;
        }
    </style>
</head>

<body>

    <h1>Dual-User Simulation & AI Features</h1>

    <div class="main-container">
        <!-- USER 1 PANEL -->
        <div class="user-panel user-1-panel">
            <h2>User 1</h2>
            <textarea id="input1" placeholder="Type as User 1..."></textarea>
            <button class="send-btn btn-user1" onclick="sendUser1()">Send >></button>
            <div id="status1" style="font-size:0.8em; color:gray; text-align:center;">Disconnected</div>
        </div>

        <!-- CENTER CHAT AREA -->
        <div class="chat-container">
            <div id="messages"></div>

            <!-- AI CONTROLS -->
            <div class="controls">
                <label for="featureSelect"><strong>AI Feature:</strong></label>
                <select id="featureSelect">
                    <option value="none">-- Select Feature --</option>
                    <option value="prioritize">Message Prioritization</option>
                    <option value="moderate">AI Moderation</option>
                    <option value="smart_replies">Smart Replies</option>
                    <option value="summary">Chat Summary</option>
                    <option value="tasks">Extract Tasks</option>
                    <option value="reminders">Smart Reminders</option>
                    <option value="translate">Language Translation</option>
                    <option value="transcribe">Audio Transcription</option>
                </select>
                <label for="translationLanguage"><strong>Language:</strong></label>
                <select id="translationLanguage">
                    <option value="en">English</option>
                    <option value="es">Spanish</option>
                    <option value="fr">French</option>
                    <option value="de">German</option>
                    <option value="hi">Hindi</option>
                    <option value="zh">Chinese</option>
                    <option value="ja">Japanese</option>
                </select>
                <button class="btn-ai" onclick="runAIFeature()">Run Analysis</button>
            </div>
            <div id="aiStatus" style="font-size:0.8em; color:gray; text-align:center; padding-bottom: 5px;">Ready</div>
        </div>

        <!-- USER 2 PANEL -->
        <div class="user-panel user-2-panel">
            <h2>User 2</h2>
            <textarea id="input2" placeholder="Type as User 2..."></textarea>
            <button class="send-btn btn-user2" onclick="sendUser2()">
                << Send</button>
                    <div id="status2" style="font-size:0.8em; color:gray; text-align:center;">Disconnected</div>
        </div>
    </div>

    <!-- Summary Modal -->
    <div id="summaryModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeSummary()">&times;</span>
            <h2>Chat Summary</h2>
            <div id="summaryLoading" style="display: none; text-align: center; padding: 20px;">Generating summary...
            </div>
            <div id="summaryResults"></div>
        </div>
    </div>

    <!-- Tasks Modal -->
    <div id="tasksModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeTasks()">&times;</span>
            <h2>Chat Tasks / To-Dos</h2>
            <div id="tasksLoading" style="display: none; text-align: center; padding: 20px;">Extracting tasks...</div>
            <div id="tasksResults"></div>
        </div>
    </div>

    <!-- Reminders Modal -->
    <div id="remindersModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeReminders()">&times;</span>
            <h2>Smart Reminder Suggestions</h2>
            <div style="margin-bottom: 15px;">
                <label for="reminderContextWindow">Context Window (recent messages): </label>
                <input type="number" id="reminderContextWindow" value="" placeholder="All messages" min="1"
                    style="width: 100px; padding: 5px; margin-left: 10px;">
            </div>
            <div id="remindersLoading" style="display: none; text-align: center; padding: 20px;">Generating reminder
                suggestions...</div>
            <div id="remindersResults"></div>
        </div>
    </div>

    <!-- Transcription Modal -->
    <div id="transcriptionModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeTranscription()">&times;</span>
            <h2>Audio Transcription</h2>
            <div style="margin-bottom: 20px; text-align: center;">
                <input type="file" id="audioInput" accept="audio/*" style="display: block; margin: 10px auto;">
                <button class="btn-ai" onclick="uploadForTranscription()">Transcribe Now</button>
                <button id="btnSummarizeTranscript" class="btn-ai"
                    style="display:none; margin-left:10px; background-color: #ff9800;"
                    onclick="generateTranscriptSummary()">Generate Summary</button>
            </div>
            <div id="transcriptionLoading" style="display: none; text-align: center; padding: 20px;">Transcribing audio
                file...</div>
            <div id="transcriptionResults"
                style="white-space: pre-wrap; background: #f9f9f9; padding: 15px; border-radius: 5px; margin-top: 10px; min-height: 100px;">
            </div>
            <div id="transcriptionSummaryResult"
                style="margin-top: 20px; border-top: 1px solid #ccc; padding-top: 10px;"></div>
        </div>
    </div>
    </div>



    <script>
        // --- WebSocket Setup ---
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const host = window.location.host;

        let ws1, ws2;
        const user1Name = "User 1";
        const user2Name = "User 2";

        // Global store for messages to easily update UI
        let chatMessages = [];

        // Utility function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function connect() {
            // Connect User 1
            ws1 = new WebSocket(`${protocol}//${host}/ws?username=${encodeURIComponent(user1Name)}`);
            ws1.onopen = () => updateStatus('status1', 'Connected (Online)', 'green');
            ws1.onclose = () => updateStatus('status1', 'Disconnected', 'red');
            ws1.onmessage = (e) => handleMessage(e);

            // Connect User 2
            ws2 = new WebSocket(`${protocol}//${host}/ws?username=${encodeURIComponent(user2Name)}`);
            ws2.onopen = () => updateStatus('status2', 'Connected (Online)', 'green');
            ws2.onclose = () => updateStatus('status2', 'Disconnected', 'red');
            ws2.onmessage = (e) => handleMessage(e); // Both listen, but backend broadcasts to all
        }

        function updateStatus(elemId, text, color) {
            const el = document.getElementById(elemId);
            el.textContent = text;
            el.style.color = color;
        }

        // Handle incoming messages
        function handleMessage(event) {
            const data = JSON.parse(event.data);

            // We only care about actual 'message' types to display in the main chat
            // Dual connection means we might receive duplicates if we aren't careful, 
            // but the backend `exclude_user_id` logic usually handles "echo".
            // However, since we have ONE UI showing ALL messages, we need to be careful.
            // Simplified: The backend broadcasts to everyone except sender.
            // BUT, our UI needs to show the sender's own message too immediately?
            // Actually, best pattern: Sender adds locally, others receive via WS.
            // OR: Backend broadcasts to EVERYONE including sender (simpler for state sync).

            // In the provided `main.py`, it uses `exclude_user_id`.
            // So User 1 sends -> Backend -> User 2 receives.
            // User 1 needs to see their own message. 
            // We'll handle "own message" display in the send function for immediate feedback,
            // OR better: we utilize the existing logic.
            // Let's just listen. User 1 sends. User 2 receives. 
            // Since this is a "Central View", we should just append messages as they come In.
            // Problem: ws1.onmessage only gets messages from OTHERS (User 2).
            // ws2.onmessage only gets messages from OTHERS (User 1).
            // So if User 1 sends, ws2 receives it. We display it.
            // If User 2 sends, ws1 receives it. We display it.
            // Perfect!

            if (data.type === 'message') {
                displayMessage(data);
            }
        }

        function displayMessage(msgData) {
            // Avoid duplicates if both sockets receive notifications (e.g. system messages)
            // For simple chat messages between 2 people, it's distinct.

            const container = document.getElementById('messages');
            const div = document.createElement('div');

            const isUser1 = msgData.sender === user1Name;
            div.className = `message ${isUser1 ? 'left' : 'right'}`;
            div.dataset.id = msgData.message_id || Date.now(); // Ensure ID exists for AI features

            div.innerHTML = `
                <div class="message-header">${msgData.sender}</div>
                <div class="message-body">${msgData.message}</div>
                <div class="ai-tags"></div>
            `;

            container.appendChild(div);
            container.scrollTop = container.scrollHeight;

            // Keep track for AI analysis
            chatMessages.push({
                id: div.dataset.id,
                sender: msgData.sender,
                message: msgData.message,
                element: div
            });
        }

        function sendUser1() {
            const input = document.getElementById('input1');
            const text = input.value.trim();
            if (!text) return;

            // Send via WS - Do NOT display locally, wait for WS echo/broadcast to other user
            // Since we have both User 1 and User 2 sockets open:
            // User 1 sends -> Backend -> User 2 receives -> We display from User 2's socket event.
            ws1.send(JSON.stringify({ message: text }));

            input.value = '';
        }

        function sendUser2() {
            const input = document.getElementById('input2');
            const text = input.value.trim();
            if (!text) return;

            // Send via WS
            ws2.send(JSON.stringify({ message: text }));

            input.value = '';
        }

        // --- AI Features ---

        async function runAIFeature() {
            const feature = document.getElementById('featureSelect').value;
            const statusEl = document.getElementById('aiStatus');

            if (feature === 'none') {
                alert("Please select a feature.");
                return;
            }

            if (feature === 'transcribe') {
                document.getElementById('transcriptionModal').style.display = 'block';
                return;
            }

            if (feature === 'transcribe') {
                document.getElementById('transcriptionModal').style.display = 'block';
                return;
            }

            if (chatMessages.length === 0) {
                alert("No messages to analyze.");
                return;
            }

            // Handle summary and tasks features directly (they open modals)
            if (feature === 'summary') {
                await generateSummary();
                return;
            }

            if (feature === 'tasks') {
                await generateTasks();
                return;
            }

            if (feature === 'translate') {
                await translateMessages();
                return;
            }

            if (feature === 'transcribe') {
                document.getElementById('transcriptionModal').style.display = 'block';
                return;
            }

            if (feature === 'reminders') {
                await generateReminderSuggestions();
                return;
            }

            // Handle other AI features (prioritize, moderate, smart_replies)
            statusEl.textContent = "Analyzing...";

            try {
                // Prepare payload: List of messages
                const payload = chatMessages.map(m => ({
                    id: m.id,
                    sender: m.sender,
                    message: m.message
                }));

                let url = `/api/features/${feature}`;
                if (feature === 'smart_replies') url = '/api/features/smart-replies';

                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                console.log("AI Result:", result); // Debug log

                if (feature === 'prioritize') {
                    applyPriorities(result);
                } else if (feature === 'moderate') {
                    applyModeration(result);
                } else if (feature === 'smart_replies') {
                    showSmartReplies(result);
                }

                statusEl.textContent = "Analysis Complete. Check messages for tags.";

            } catch (error) {
                console.error(error);
                statusEl.textContent = "Error during analysis.";
            }
        }

        function applyPriorities(data) {
            // data format: { "msg_id": "High", ... }
            let appliedCount = 0;
            chatMessages.forEach(msg => {
                const priority = data[msg.id];
                if (priority) {
                    const tagContainer = msg.element.querySelector('.ai-tags');
                    // distinct removal
                    const oldTags = tagContainer.querySelectorAll('.tag-priority');
                    oldTags.forEach(e => e.remove());

                    let className = 'tag-normal';
                    if (priority.toLowerCase() === 'urgent') className = 'tag-urgent';
                    if (priority.toLowerCase() === 'high') className = 'tag-high';

                    // Always show the tag for clarity now
                    const span = document.createElement('span');
                    span.className = `tag ${className} tag-priority`;
                    span.textContent = priority;
                    tagContainer.appendChild(span);
                    appliedCount++;
                }
            });
            if (appliedCount === 0) alert("No priorities returned or IDs mismatch.");
        }

        function applyModeration(data) {
            // data format: { "msg_id": { "safe": false, "reason": "spam" } }
            let appliedCount = 0;
            chatMessages.forEach(msg => {
                const modResult = data[msg.id];
                if (modResult) {
                    const tagContainer = msg.element.querySelector('.ai-tags');
                    const oldTags = tagContainer.querySelectorAll('.tag-mod');
                    oldTags.forEach(e => e.remove());

                    if (!modResult.safe) {
                        const span = document.createElement('span');
                        span.className = 'tag tag-unsafe tag-mod';
                        span.title = modResult.reason || "Unsafe";
                        span.textContent = `Unsafe: ${modResult.reason || ''}`;
                        tagContainer.appendChild(span);
                    } else {
                        const span = document.createElement('span');
                        span.className = 'tag tag-safe tag-mod';
                        span.textContent = "Safe";
                        tagContainer.appendChild(span);
                    }
                    appliedCount++;
                }
            });
            if (appliedCount === 0) alert("No moderation results or IDs mismatch.");
        }

        function showSmartReplies(data) {
            // data format: { "suggestions": ["Yes", "No"] }
            // Apply to the simulation of the LAST user who received a message?
            // Usually Smart Replies are for the *current* user to reply to the *last* message.
            // Let's assume User 1 wants to reply to User 2 (or vice versa).
            // We'll show suggestions in the controls area or alert for now.
            // Better: Show a temporary "Suggestions" box in the chat center.

            const suggestions = data.suggestions;
            if (!suggestions || suggestions.length === 0) return;

            const container = document.getElementById('messages');
            const div = document.createElement('div');
            div.className = 'suggestion-box';
            div.innerHTML = `<strong>AI Suggestions:</strong><br/>`;

            suggestions.forEach(s => {
                const btn = document.createElement('button');
                btn.className = 'suggestion-btn';
                btn.textContent = s;
                btn.onclick = () => {
                    // Smartly decide which user is replying
                    // If the last message was from User 1, then User 2 is replying.
                    const lastMsg = chatMessages[chatMessages.length - 1];
                    if (lastMsg && lastMsg.sender === user1Name) {
                        document.getElementById('input2').value = s;
                    } else {
                        document.getElementById('input1').value = s;
                    }
                    div.remove();
                };
                div.appendChild(btn);
            });

            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }

        // Summary functionality
        async function generateSummary() {
            if (chatMessages.length === 0) {
                alert("No messages to summarize.");
                return;
            }

            const modal = document.getElementById('summaryModal');
            const loading = document.getElementById('summaryLoading');
            const results = document.getElementById('summaryResults');

            modal.style.display = 'block';
            loading.style.display = 'block';
            results.innerHTML = '';

            try {
                // Use User 1 as the username for summary (or could be configurable)
                const username = user1Name;
                const response = await fetch(`/api/features/chat-summarize?username=${encodeURIComponent(username)}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });
                const data = await response.json();

                if (!response.ok) {
                    const detail = data && data.detail ? data.detail : 'Server returned an error';
                    throw new Error(detail);
                }

                const summary = data.summary || 'No summary available.';
                const totalMessages = typeof data.total_messages === 'number' ? data.total_messages : 0;
                const participants = Array.isArray(data.participants) ? data.participants : [];
                const bulletPoints = Array.isArray(data.bullet_points) ? data.bullet_points : [];
                const keyDecisions = Array.isArray(data.key_decisions) ? data.key_decisions : [];
                const actionItems = Array.isArray(data.action_items) ? data.action_items : [];
                const unreadSummary = data.unread_summary || 'No unread summary available.';

                loading.style.display = 'none';

                let html = `
                    <div class="summary-section">
                        <h3>üìã Overview</h3>
                        <p>${summary}</p>
                        <p><strong>Total Messages:</strong> ${totalMessages}</p>
                        <p><strong>Participants:</strong> ${participants.join(', ')}</p>
                    </div>
                    
                    <div class="summary-section">
                        <h3>üí¨ What Did I Miss?</h3>
                        <p>${unreadSummary}</p>
                    </div>
                    
                    <div class="summary-section">
                        <h3>üìù Key Points</h3>
                        <ul>
                            ${bulletPoints.map(point => `<li>${point}</li>`).join('')}
                        </ul>
                    </div>
                    
                    <div class="summary-section">
                        <h3>‚úÖ Key Decisions</h3>
                        <ul>
                            ${keyDecisions.map(decision => `<li>${decision}</li>`).join('')}
                        </ul>
                    </div>
                    
                    <div class="summary-section">
                        <h3>üéØ Action Items</h3>
                        <ul>
                            ${actionItems.map(action => `<li>${action}</li>`).join('')}
                        </ul>
                    </div>
                `;

                results.innerHTML = html;
            } catch (error) {
                loading.style.display = 'none';
                results.innerHTML = `<p style="color: red;">Error generating summary: ${error.message}</p>`;
            }
        }

        function closeSummary() {
            document.getElementById('summaryModal').style.display = 'none';
        }

        // Tasks classification functionality
        async function generateTasks() {
            if (chatMessages.length === 0) {
                alert("No messages to analyze for tasks.");
                return;
            }

            const modal = document.getElementById('tasksModal');
            const loading = document.getElementById('tasksLoading');
            const results = document.getElementById('tasksResults');

            modal.style.display = 'block';
            loading.style.display = 'block';
            results.innerHTML = '';

            try {
                // Use User 1 as the username for tasks (or could be configurable)
                const username = user1Name;
                const response = await fetch(`/api/features/tasks-classifier?username=${encodeURIComponent(username)}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });
                const data = await response.json();

                if (!response.ok) {
                    const detail = data && data.detail ? data.detail : 'Server returned an error';
                    throw new Error(detail);
                }

                const tasks = Array.isArray(data.tasks) ? data.tasks : [];
                loading.style.display = 'none';

                if (tasks.length === 0) {
                    results.innerHTML = '<p>No tasks found in the current conversation.</p>';
                    return;
                }

                const tasksHtml = tasks.map((task, index) => {
                    const title = task.title || '(untitled task)';
                    const desc = task.description || '';
                    const assignee = task.assignee || 'Unassigned';
                    const due = task.due_date || 'No deadline';
                    const status = task.status || 'todo';
                    const sourceTime = task.timestamp || '';
                    const taskId = task.id || '';

                    return `
                        <div class="summary-section" data-task-index="${index}">
                            <h3>üìù ${escapeHtml(title)}</h3>
                            <p>${escapeHtml(desc)}</p>
                            <p><strong>Status:</strong> ${status}</p>
                            <p><strong>Assignee:</strong> ${escapeHtml(assignee)}</p>
                            <p><strong>Due date:</strong> ${due}</p>
                            ${sourceTime ? `<p><strong>From message at:</strong> ${sourceTime}</p>` : ''}
                            <button class="task-reminder-btn" data-task-id="${taskId}" data-task-title="${escapeHtml(title)}" data-task-desc="${escapeHtml(desc)}" data-task-due="${due}" data-task-assignee="${escapeHtml(assignee)}">
                                üîî Create Reminder
                            </button>
                        </div>
                    `;
                }).join('');

                results.innerHTML = tasksHtml;

                // Attach event listeners to reminder buttons
                results.querySelectorAll('.task-reminder-btn').forEach(btn => {
                    btn.addEventListener('click', function () {
                        const taskId = this.getAttribute('data-task-id');
                        const title = this.getAttribute('data-task-title');
                        const desc = this.getAttribute('data-task-desc');
                        const due = this.getAttribute('data-task-due');
                        const assignee = this.getAttribute('data-task-assignee');
                        createReminderFromTask(taskId, title, desc, due, assignee);
                    });
                });
            } catch (error) {
                loading.style.display = 'none';
                results.innerHTML = `<p style="color: red;">Error extracting tasks: ${error.message}</p>`;
            }
        }

        function closeTasks() {
            document.getElementById('tasksModal').style.display = 'none';
        }

        // Language translation functionality
        async function translateMessages() {
            if (chatMessages.length === 0) {
                alert("No messages to translate.");
                return;
            }

            const statusEl = document.getElementById('aiStatus');
            const langSelect = document.getElementById('translationLanguage');
            const targetLang = langSelect ? langSelect.value : 'en';
            const targetLangLabel = langSelect
                ? langSelect.options[langSelect.selectedIndex].text
                : targetLang.toUpperCase();

            statusEl.textContent = `Translating messages to ${targetLangLabel}...`;

            try {
                const payload = chatMessages.map(m => ({
                    id: m.id,
                    text: m.message,
                    target_language: targetLang
                }));

                const response = await fetch('/api/features/translate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();

                if (!response.ok) {
                    const detail = data && data.detail ? data.detail : 'Server returned an error';
                    throw new Error(detail);
                }

                applyTranslations(data, targetLangLabel);
                statusEl.textContent = `Translation complete (${targetLangLabel}).`;
            } catch (error) {
                console.error(error);
                statusEl.textContent = "Error during translation.";
                alert(`Error translating messages: ${error.message}`);
            }
        }

        function applyTranslations(data, targetLangLabel) {
            const translations = data && data.translations ? data.translations : {};
            let appliedCount = 0;

            chatMessages.forEach(msg => {
                const t = translations[msg.id];
                if (t && t.translated_text) {
                    const container = msg.element;

                    // Remove any existing translation box for this message
                    const existing = container.querySelector('.translation-box');
                    if (existing) {
                        existing.remove();
                    }

                    const div = document.createElement('div');
                    div.className = 'translation-box';
                    div.innerHTML = `
                        <div class="translation-header">Translated (${targetLangLabel})</div>
                        <div class="translation-body">${escapeHtml(t.translated_text)}</div>
                    `;

                    container.appendChild(div);
                    appliedCount++;
                }
            });

            if (appliedCount === 0) {
                alert("No translations returned or IDs mismatch.");
            }
        }

        // Smart Reminders functionality
        async function generateReminderSuggestions() {
            if (chatMessages.length === 0) {
                alert("No messages to analyze for reminders.");
                return;
            }

            const modal = document.getElementById('remindersModal');
            const loading = document.getElementById('remindersLoading');
            const results = document.getElementById('remindersResults');
            const contextWindowInput = document.getElementById('reminderContextWindow');

            modal.style.display = 'block';
            loading.style.display = 'block';
            results.innerHTML = '';

            try {
                const username = user1Name;
                const contextWindow = contextWindowInput.value ? parseInt(contextWindowInput.value) : null;

                const requestBody = {
                    username: username,
                    context_window: contextWindow
                };

                const response = await fetch('/api/features/smart-reminders/suggestions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });

                const data = await response.json();

                if (!response.ok) {
                    const detail = data && data.detail ? data.detail : 'Server returned an error';
                    throw new Error(detail);
                }

                const suggestions = Array.isArray(data.suggestions) ? data.suggestions : [];
                loading.style.display = 'none';

                if (suggestions.length === 0) {
                    results.innerHTML = '<p>No reminder suggestions found. Try having more conversations with action items or deadlines.</p>';
                    return;
                }

                const suggestionsHtml = suggestions.map(suggestion => {
                    const id = suggestion.id || '';
                    const title = suggestion.title || '(untitled)';
                    const desc = suggestion.description || '';
                    const dueDate = suggestion.suggested_due_date || 'No deadline';
                    const priority = (suggestion.priority || 'medium').toLowerCase();
                    const context = suggestion.context || '';
                    const confidence = suggestion.confidence || 0;

                    const priorityClass = `priority-${priority}`;
                    const priorityLabel = priority.charAt(0).toUpperCase() + priority.slice(1);

                    return `
                        <div class="reminder-suggestion" data-suggestion-id="${id}">
                            <h4>${escapeHtml(title)}</h4>
                            <p>${escapeHtml(desc)}</p>
                            ${context ? `<p class="reminder-meta"><em>"${escapeHtml(context)}"</em></p>` : ''}
                            <div class="reminder-meta">
                                <span class="reminder-priority ${priorityClass}">${priorityLabel}</span>
                                <span>Due: ${dueDate}</span>
                                <span style="margin-left: 10px;">Confidence: ${(confidence * 100).toFixed(0)}%</span>
                            </div>
                            <div class="reminder-actions">
                                <button class="btn-create-reminder" data-suggestion-id="${id}" data-suggestion-title="${escapeHtml(title)}" data-suggestion-desc="${escapeHtml(desc)}" data-suggestion-due="${dueDate}">
                                    Create Reminder
                                </button>
                            </div>
                        </div>
                    `;
                }).join('');

                results.innerHTML = suggestionsHtml;

                // Attach event listeners to reminder creation buttons
                results.querySelectorAll('.btn-create-reminder').forEach(btn => {
                    btn.addEventListener('click', function () {
                        const id = this.getAttribute('data-suggestion-id');
                        const title = this.getAttribute('data-suggestion-title');
                        const desc = this.getAttribute('data-suggestion-desc');
                        const dueDate = this.getAttribute('data-suggestion-due');
                        createReminderFromSuggestion(id, title, desc, dueDate, null);
                    });
                });
            } catch (error) {
                loading.style.display = 'none';
                results.innerHTML = `<p style="color: red;">Error generating reminder suggestions: ${error.message}</p>`;
            }
        }

        function closeReminders() {
            document.getElementById('remindersModal').style.display = 'none';
        }

        async function createReminderFromSuggestion(suggestionId, title, description, dueDate, assignee) {
            try {
                const requestBody = {
                    task_id: suggestionId,
                    title: title,
                    description: description || null,
                    due_date: dueDate !== 'No deadline' ? dueDate : null,
                    assignee: assignee || null,
                    reminder_time: null
                };

                const response = await fetch('/api/features/smart-reminders/create', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });

                const data = await response.json();

                if (!response.ok) {
                    const detail = data && data.detail ? data.detail : 'Server returned an error';
                    throw new Error(detail);
                }

                // Show success message
                const results = document.getElementById('remindersResults');
                const successMsg = document.createElement('div');
                successMsg.className = 'reminder-created';
                successMsg.innerHTML = `
                    <strong>‚úÖ Reminder Created!</strong>
                    <p><strong>Title:</strong> ${data.title}</p>
                    ${data.due_date ? `<p><strong>Due Date:</strong> ${data.due_date}</p>` : ''}
                    ${data.reminder_time ? `<p><strong>Reminder Time:</strong> ${new Date(data.reminder_time).toLocaleString()}</p>` : ''}
                    <p><strong>Status:</strong> ${data.status}</p>
                `;
                results.insertBefore(successMsg, results.firstChild);

                // Remove the suggestion from the list
                const suggestionElement = results.querySelector(`[data-suggestion-id="${suggestionId}"]`);
                if (suggestionElement) {
                    // Add a fade-out animation before removing
                    suggestionElement.style.transition = 'opacity 0.3s ease-out';
                    suggestionElement.style.opacity = '0';
                    setTimeout(() => {
                        suggestionElement.remove();

                        // If no suggestions remain, show a message
                        const remainingSuggestions = results.querySelectorAll('.reminder-suggestion');
                        if (remainingSuggestions.length === 0) {
                            results.innerHTML = '<p>All reminders have been created. No more suggestions available.</p>';
                        }
                    }, 300);
                }

                // Scroll to top to show the success message
                results.scrollTop = 0;

                // Remove success message after 5 seconds
                setTimeout(() => {
                    successMsg.remove();
                }, 5000);

            } catch (error) {
                alert(`Error creating reminder: ${error.message}`);
            }
        }

        async function createReminderFromTask(taskId, title, description, dueDate, assignee) {
            try {
                const requestBody = {
                    task_id: taskId,
                    title: title,
                    description: description || null,
                    due_date: dueDate !== 'No deadline' ? dueDate : null,
                    assignee: assignee !== 'Unassigned' ? assignee : null,
                    reminder_time: null
                };

                const response = await fetch('/api/features/smart-reminders/create', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });

                const data = await response.json();

                if (!response.ok) {
                    const detail = data && data.detail ? data.detail : 'Server returned an error';
                    throw new Error(detail);
                }

                // Show success message in tasks modal
                const results = document.getElementById('tasksResults');
                const successMsg = document.createElement('div');
                successMsg.className = 'reminder-created';
                successMsg.innerHTML = `
                    <strong>‚úÖ Reminder Created from Task!</strong>
                    <p><strong>Title:</strong> ${data.title}</p>
                    ${data.due_date ? `<p><strong>Due Date:</strong> ${data.due_date}</p>` : ''}
                    ${data.reminder_time ? `<p><strong>Reminder Time:</strong> ${new Date(data.reminder_time).toLocaleString()}</p>` : ''}
                    <p><strong>Status:</strong> ${data.status}</p>
                `;
                results.insertBefore(successMsg, results.firstChild);

                // Scroll to top to show the success message
                results.scrollTop = 0;

                // Remove success message after 5 seconds
                setTimeout(() => {
                    successMsg.remove();
                }, 5000);

            } catch (error) {
                alert(`Error creating reminder: ${error.message}`);
            }
        }

        // Close modal when clicking outside
        // Transcription functionality
        async function uploadForTranscription() {
            const fileInput = document.getElementById('audioInput');
            const file = fileInput.files[0];

            if (!file) {
                alert("Please select an audio file first.");
                return;
            }

            const loading = document.getElementById('transcriptionLoading');
            const results = document.getElementById('transcriptionResults');

            loading.style.display = 'block';
            results.textContent = '';

            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/api/features/transcribe', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                loading.style.display = 'none';

                if (!response.ok) {
                    throw new Error(data.detail || 'Transcription failed');
                }

                results.textContent = data.transcription;

                // Show the "Generate Summary" button
                document.getElementById('btnSummarizeTranscript').style.display = 'inline-block';

            } catch (error) {
                loading.style.display = 'none';
                results.innerHTML = `<span style="color:red">Error: ${error.message}</span>`;
            }
        }

        async function generateTranscriptSummary() {
            const transcriptText = document.getElementById('transcriptionResults').textContent;
            if (!transcriptText) return;

            const results = document.getElementById('transcriptionSummaryResult');

            // Show loading state directly in the result div
            results.innerHTML = '<div style="text-align:center; padding:10px;">Generating summary...</div>';

            try {
                const response = await fetch('/api/features/summarize-text', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: transcriptText })
                });

                const data = await response.json();

                let html = `
                    <div class="summary-section">
                        <h3>üìã Overview</h3>
                        <p>${data.summary}</p>
                    </div>
                    
                    <div class="summary-section">
                        <h3>‚ÑπÔ∏è Key Points</h3>
                        <ul>
                            ${data.bullet_points.map(p => `<li>${p}</li>`).join('')}
                        </ul>
                    </div>

                    <div class="summary-section">
                        <h3>‚öñÔ∏è Key Decisions</h3>
                        <ul>
                            ${data.key_decisions.map(d => `<li>${d}</li>`).join('')}
                        </ul>
                    </div>

                    <div class="summary-section">
                        <h3>‚úÖ Action Items</h3>
                        <ul>
                            ${data.action_items.map(a => `<li>${a}</li>`).join('')}
                        </ul>
                    </div>
                `;
                results.innerHTML = html;

            } catch (error) {
                results.innerHTML = `<p style="color:red">Error generating summary: ${error.message}</p>`;
            }
        }

        function closeTranscription() {
            document.getElementById('transcriptionModal').style.display = 'none';
        }

        // Close modal when clicking outside
        window.onclick = function (event) {
            const summaryModal = document.getElementById('summaryModal');
            const tasksModal = document.getElementById('tasksModal');
            const remindersModal = document.getElementById('remindersModal');
            const transcriptionModal = document.getElementById('transcriptionModal');

            if (event.target == summaryModal) summaryModal.style.display = 'none';
            if (event.target == tasksModal) tasksModal.style.display = 'none';
            if (event.target == remindersModal) remindersModal.style.display = 'none';
            if (event.target == transcriptionModal) transcriptionModal.style.display = 'none';
        }

        // Initial Connect
        connect();

    </script>
</body>

</html>